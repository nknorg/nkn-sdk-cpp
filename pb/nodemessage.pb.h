// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb/nodemessage.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pb_2fnodemessage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pb_2fnodemessage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "pb/node.pb.h"
#include "pb/sigchain.pb.h"
#include "pb/block.pb.h"
#include "pb/transaction.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pb_2fnodemessage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pb_2fnodemessage_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_pb_2fnodemessage_2eproto;
namespace pb {
class BacktrackSignatureChain;
struct BacktrackSignatureChainDefaultTypeInternal;
extern BacktrackSignatureChainDefaultTypeInternal _BacktrackSignatureChain_default_instance_;
class GetBlockHeaders;
struct GetBlockHeadersDefaultTypeInternal;
extern GetBlockHeadersDefaultTypeInternal _GetBlockHeaders_default_instance_;
class GetBlockHeadersReply;
struct GetBlockHeadersReplyDefaultTypeInternal;
extern GetBlockHeadersReplyDefaultTypeInternal _GetBlockHeadersReply_default_instance_;
class GetBlocks;
struct GetBlocksDefaultTypeInternal;
extern GetBlocksDefaultTypeInternal _GetBlocks_default_instance_;
class GetBlocksReply;
struct GetBlocksReplyDefaultTypeInternal;
extern GetBlocksReplyDefaultTypeInternal _GetBlocksReply_default_instance_;
class GetConsensusState;
struct GetConsensusStateDefaultTypeInternal;
extern GetConsensusStateDefaultTypeInternal _GetConsensusState_default_instance_;
class GetConsensusStateReply;
struct GetConsensusStateReplyDefaultTypeInternal;
extern GetConsensusStateReplyDefaultTypeInternal _GetConsensusStateReply_default_instance_;
class GetStates;
struct GetStatesDefaultTypeInternal;
extern GetStatesDefaultTypeInternal _GetStates_default_instance_;
class GetStatesReply;
struct GetStatesReplyDefaultTypeInternal;
extern GetStatesReplyDefaultTypeInternal _GetStatesReply_default_instance_;
class IHaveBlockProposal;
struct IHaveBlockProposalDefaultTypeInternal;
extern IHaveBlockProposalDefaultTypeInternal _IHaveBlockProposal_default_instance_;
class IHaveSignatureChainTransaction;
struct IHaveSignatureChainTransactionDefaultTypeInternal;
extern IHaveSignatureChainTransactionDefaultTypeInternal _IHaveSignatureChainTransaction_default_instance_;
class PinSignatureChain;
struct PinSignatureChainDefaultTypeInternal;
extern PinSignatureChainDefaultTypeInternal _PinSignatureChain_default_instance_;
class Relay;
struct RelayDefaultTypeInternal;
extern RelayDefaultTypeInternal _Relay_default_instance_;
class RequestBlockProposal;
struct RequestBlockProposalDefaultTypeInternal;
extern RequestBlockProposalDefaultTypeInternal _RequestBlockProposal_default_instance_;
class RequestBlockProposalReply;
struct RequestBlockProposalReplyDefaultTypeInternal;
extern RequestBlockProposalReplyDefaultTypeInternal _RequestBlockProposalReply_default_instance_;
class RequestProposalTransactions;
struct RequestProposalTransactionsDefaultTypeInternal;
extern RequestProposalTransactionsDefaultTypeInternal _RequestProposalTransactions_default_instance_;
class RequestProposalTransactionsReply;
struct RequestProposalTransactionsReplyDefaultTypeInternal;
extern RequestProposalTransactionsReplyDefaultTypeInternal _RequestProposalTransactionsReply_default_instance_;
class RequestSignatureChainTransaction;
struct RequestSignatureChainTransactionDefaultTypeInternal;
extern RequestSignatureChainTransactionDefaultTypeInternal _RequestSignatureChainTransaction_default_instance_;
class RequestSignatureChainTransactionReply;
struct RequestSignatureChainTransactionReplyDefaultTypeInternal;
extern RequestSignatureChainTransactionReplyDefaultTypeInternal _RequestSignatureChainTransactionReply_default_instance_;
class SignatureChainObjectionSigned;
struct SignatureChainObjectionSignedDefaultTypeInternal;
extern SignatureChainObjectionSignedDefaultTypeInternal _SignatureChainObjectionSigned_default_instance_;
class SignatureChainObjectionUnsigned;
struct SignatureChainObjectionUnsignedDefaultTypeInternal;
extern SignatureChainObjectionUnsignedDefaultTypeInternal _SignatureChainObjectionUnsigned_default_instance_;
class SignedMessage;
struct SignedMessageDefaultTypeInternal;
extern SignedMessageDefaultTypeInternal _SignedMessage_default_instance_;
class StateNode;
struct StateNodeDefaultTypeInternal;
extern StateNodeDefaultTypeInternal _StateNode_default_instance_;
class StateRequest;
struct StateRequestDefaultTypeInternal;
extern StateRequestDefaultTypeInternal _StateRequest_default_instance_;
class Transactions;
struct TransactionsDefaultTypeInternal;
extern TransactionsDefaultTypeInternal _Transactions_default_instance_;
class UnsignedMessage;
struct UnsignedMessageDefaultTypeInternal;
extern UnsignedMessageDefaultTypeInternal _UnsignedMessage_default_instance_;
class Vote;
struct VoteDefaultTypeInternal;
extern VoteDefaultTypeInternal _Vote_default_instance_;
}  // namespace pb
PROTOBUF_NAMESPACE_OPEN
template<> ::pb::BacktrackSignatureChain* Arena::CreateMaybeMessage<::pb::BacktrackSignatureChain>(Arena*);
template<> ::pb::GetBlockHeaders* Arena::CreateMaybeMessage<::pb::GetBlockHeaders>(Arena*);
template<> ::pb::GetBlockHeadersReply* Arena::CreateMaybeMessage<::pb::GetBlockHeadersReply>(Arena*);
template<> ::pb::GetBlocks* Arena::CreateMaybeMessage<::pb::GetBlocks>(Arena*);
template<> ::pb::GetBlocksReply* Arena::CreateMaybeMessage<::pb::GetBlocksReply>(Arena*);
template<> ::pb::GetConsensusState* Arena::CreateMaybeMessage<::pb::GetConsensusState>(Arena*);
template<> ::pb::GetConsensusStateReply* Arena::CreateMaybeMessage<::pb::GetConsensusStateReply>(Arena*);
template<> ::pb::GetStates* Arena::CreateMaybeMessage<::pb::GetStates>(Arena*);
template<> ::pb::GetStatesReply* Arena::CreateMaybeMessage<::pb::GetStatesReply>(Arena*);
template<> ::pb::IHaveBlockProposal* Arena::CreateMaybeMessage<::pb::IHaveBlockProposal>(Arena*);
template<> ::pb::IHaveSignatureChainTransaction* Arena::CreateMaybeMessage<::pb::IHaveSignatureChainTransaction>(Arena*);
template<> ::pb::PinSignatureChain* Arena::CreateMaybeMessage<::pb::PinSignatureChain>(Arena*);
template<> ::pb::Relay* Arena::CreateMaybeMessage<::pb::Relay>(Arena*);
template<> ::pb::RequestBlockProposal* Arena::CreateMaybeMessage<::pb::RequestBlockProposal>(Arena*);
template<> ::pb::RequestBlockProposalReply* Arena::CreateMaybeMessage<::pb::RequestBlockProposalReply>(Arena*);
template<> ::pb::RequestProposalTransactions* Arena::CreateMaybeMessage<::pb::RequestProposalTransactions>(Arena*);
template<> ::pb::RequestProposalTransactionsReply* Arena::CreateMaybeMessage<::pb::RequestProposalTransactionsReply>(Arena*);
template<> ::pb::RequestSignatureChainTransaction* Arena::CreateMaybeMessage<::pb::RequestSignatureChainTransaction>(Arena*);
template<> ::pb::RequestSignatureChainTransactionReply* Arena::CreateMaybeMessage<::pb::RequestSignatureChainTransactionReply>(Arena*);
template<> ::pb::SignatureChainObjectionSigned* Arena::CreateMaybeMessage<::pb::SignatureChainObjectionSigned>(Arena*);
template<> ::pb::SignatureChainObjectionUnsigned* Arena::CreateMaybeMessage<::pb::SignatureChainObjectionUnsigned>(Arena*);
template<> ::pb::SignedMessage* Arena::CreateMaybeMessage<::pb::SignedMessage>(Arena*);
template<> ::pb::StateNode* Arena::CreateMaybeMessage<::pb::StateNode>(Arena*);
template<> ::pb::StateRequest* Arena::CreateMaybeMessage<::pb::StateRequest>(Arena*);
template<> ::pb::Transactions* Arena::CreateMaybeMessage<::pb::Transactions>(Arena*);
template<> ::pb::UnsignedMessage* Arena::CreateMaybeMessage<::pb::UnsignedMessage>(Arena*);
template<> ::pb::Vote* Arena::CreateMaybeMessage<::pb::Vote>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pb {

enum MessageType : int {
  MESSAGE_TYPE_PLACEHOLDER_DO_NOT_USE = 0,
  VOTE = 1,
  I_HAVE_BLOCK_PROPOSAL = 2,
  REQUEST_BLOCK_PROPOSAL = 3,
  REQUEST_BLOCK_PROPOSAL_REPLY = 4,
  GET_CONSENSUS_STATE = 5,
  GET_CONSENSUS_STATE_REPLY = 6,
  GET_BLOCK_HEADERS = 7,
  GET_BLOCK_HEADERS_REPLY = 8,
  GET_BLOCKS = 9,
  GET_BLOCKS_REPLY = 10,
  RELAY = 11,
  TRANSACTIONS = 12,
  BACKTRACK_SIGNATURE_CHAIN = 13,
  REQUEST_PROPOSAL_TRANSACTIONS = 14,
  REQUEST_PROPOSAL_TRANSACTIONS_REPLY = 15,
  I_HAVE_SIGNATURE_CHAIN_TRANSACTION = 16,
  REQUEST_SIGNATURE_CHAIN_TRANSACTION = 17,
  REQUEST_SIGNATURE_CHAIN_TRANSACTION_REPLY = 18,
  PIN_SIGNATURE_CHAIN = 19,
  SIGNATURE_CHAIN_OBJECTION = 20,
  GET_STATES = 21,
  GET_STATES_REPLY = 22,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = MESSAGE_TYPE_PLACEHOLDER_DO_NOT_USE;
constexpr MessageType MessageType_MAX = GET_STATES_REPLY;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum AllowedSignedMessageType : int {
  ALLOW_SIGNED_PLACEHOLDER_DO_NOT_USE = 0,
  AllowedSignedMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AllowedSignedMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AllowedSignedMessageType_IsValid(int value);
constexpr AllowedSignedMessageType AllowedSignedMessageType_MIN = ALLOW_SIGNED_PLACEHOLDER_DO_NOT_USE;
constexpr AllowedSignedMessageType AllowedSignedMessageType_MAX = ALLOW_SIGNED_PLACEHOLDER_DO_NOT_USE;
constexpr int AllowedSignedMessageType_ARRAYSIZE = AllowedSignedMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AllowedSignedMessageType_descriptor();
template<typename T>
inline const std::string& AllowedSignedMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AllowedSignedMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AllowedSignedMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AllowedSignedMessageType_descriptor(), enum_t_value);
}
inline bool AllowedSignedMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AllowedSignedMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AllowedSignedMessageType>(
    AllowedSignedMessageType_descriptor(), name, value);
}
enum AllowedUnsignedMessageType : int {
  ALLOW_UNSIGNED_PLACEHOLDER_DO_NOT_USE = 0,
  ALLOW_UNSIGNED_VOTE = 1,
  ALLOW_UNSIGNED_I_HAVE_BLOCK_PROPOSAL = 2,
  ALLOW_UNSIGNED_REQUEST_BLOCK_PROPOSAL = 3,
  ALLOW_UNSIGNED_REQUEST_BLOCK_REPLY = 4,
  ALLOW_UNSIGNED_GET_CONSENSUS_STATE = 5,
  ALLOW_UNSIGNED_GET_CONSENSUS_STATE_REPLY = 6,
  ALLOW_UNSIGNED_GET_BLOCK_HEADERS = 7,
  ALLOW_UNSIGNED_GET_BLOCK_HEADERS_REPLY = 8,
  ALLOW_UNSIGNED_GET_BLOCKS = 9,
  ALLOW_UNSIGNED_GET_BLOCKS_REPLY = 10,
  ALLOW_UNSIGNED_RELAY = 11,
  ALLOW_UNSIGNED_TRANSACTIONS = 12,
  ALLOW_UNSIGNED_BACKTRACK_SIGNATURE_CHAIN = 13,
  ALLOW_UNSIGNED_REQUEST_PROPOSAL_TRANSACTIONS = 14,
  ALLOW_UNSIGNED_REQUEST_PROPOSAL_TRANSACTIONS_REPLY = 15,
  ALLOW_UNSIGNED_I_HAVE_SIGNATURE_CHAIN_TRANSACTION = 16,
  ALLOW_UNSIGNED_REQUEST_SIGNATURE_CHAIN_TRANSACTION = 17,
  ALLOW_UNSIGNED_REQUEST_SIGNATURE_CHAIN_TRANSACTION_REPLY = 18,
  ALLOW_UNSIGNED_PIN_SIGNATURE_CHAIN = 19,
  ALLOW_UNSIGNED_SIGNATURE_CHAIN_OBJECTION = 20,
  ALLOW_UNSIGNED_GET_STATES = 21,
  ALLOW_UNSIGNED_GET_STATES_REPLY = 22,
  AllowedUnsignedMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AllowedUnsignedMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AllowedUnsignedMessageType_IsValid(int value);
constexpr AllowedUnsignedMessageType AllowedUnsignedMessageType_MIN = ALLOW_UNSIGNED_PLACEHOLDER_DO_NOT_USE;
constexpr AllowedUnsignedMessageType AllowedUnsignedMessageType_MAX = ALLOW_UNSIGNED_GET_STATES_REPLY;
constexpr int AllowedUnsignedMessageType_ARRAYSIZE = AllowedUnsignedMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AllowedUnsignedMessageType_descriptor();
template<typename T>
inline const std::string& AllowedUnsignedMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AllowedUnsignedMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AllowedUnsignedMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AllowedUnsignedMessageType_descriptor(), enum_t_value);
}
inline bool AllowedUnsignedMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AllowedUnsignedMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AllowedUnsignedMessageType>(
    AllowedUnsignedMessageType_descriptor(), name, value);
}
enum AllowedDirectMessageType : int {
  ALLOW_DIRECT_PLACEHOLDER_DO_NOT_USE = 0,
  ALLOW_DIRECT_VOTE = 1,
  ALLOW_DIRECT_I_HAVE_BLOCK_PROPOSAL = 2,
  ALLOW_DIRECT_REQUEST_BLOCK_PROPOSAL = 3,
  ALLOW_DIRECT_REQUEST_BLOCK_REPLY = 4,
  ALLOW_DIRECT_GET_CONSENSUS_STATE = 5,
  ALLOW_DIRECT_GET_CONSENSUS_STATE_REPLY = 6,
  ALLOW_DIRECT_GET_BLOCK_HEADERS = 7,
  ALLOW_DIRECT_GET_BLOCK_HEADERS_REPLY = 8,
  ALLOW_DIRECT_GET_BLOCKS = 9,
  ALLOW_DIRECT_GET_BLOCKS_REPLY = 10,
  ALLOW_DIRECT_BACKTRACK_SIGNATURE_CHAIN = 13,
  ALLOW_DIRECT_REQUEST_PROPOSAL_TRANSACTIONS = 14,
  ALLOW_DIRECT_REQUEST_PROPOSAL_TRANSACTIONS_REPLY = 15,
  ALLOW_DIRECT_I_HAVE_SIGNATURE_CHAIN_TRANSACTION = 16,
  ALLOW_DIRECT_REQUEST_SIGNATURE_CHAIN_TRANSACTION = 17,
  ALLOW_DIRECT_REQUEST_SIGNATURE_CHAIN_TRANSACTION_REPLY = 18,
  ALLOW_DIRECT_PIN_SIGNATURE_CHAIN = 19,
  ALLOW_DIRECT_SIGNATURE_CHAIN_OBJECTION = 20,
  ALLOW_DIRECT_GET_STATES = 21,
  ALLOW_DIRECT_GET_STATES_REPLY = 22,
  AllowedDirectMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AllowedDirectMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AllowedDirectMessageType_IsValid(int value);
constexpr AllowedDirectMessageType AllowedDirectMessageType_MIN = ALLOW_DIRECT_PLACEHOLDER_DO_NOT_USE;
constexpr AllowedDirectMessageType AllowedDirectMessageType_MAX = ALLOW_DIRECT_GET_STATES_REPLY;
constexpr int AllowedDirectMessageType_ARRAYSIZE = AllowedDirectMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AllowedDirectMessageType_descriptor();
template<typename T>
inline const std::string& AllowedDirectMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AllowedDirectMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AllowedDirectMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AllowedDirectMessageType_descriptor(), enum_t_value);
}
inline bool AllowedDirectMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AllowedDirectMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AllowedDirectMessageType>(
    AllowedDirectMessageType_descriptor(), name, value);
}
enum AllowedRelayMessageType : int {
  ALLOW_RELAY_PLACEHOLDER_DO_NOT_USE = 0,
  ALLOW_RELAY_RELAY = 11,
  AllowedRelayMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AllowedRelayMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AllowedRelayMessageType_IsValid(int value);
constexpr AllowedRelayMessageType AllowedRelayMessageType_MIN = ALLOW_RELAY_PLACEHOLDER_DO_NOT_USE;
constexpr AllowedRelayMessageType AllowedRelayMessageType_MAX = ALLOW_RELAY_RELAY;
constexpr int AllowedRelayMessageType_ARRAYSIZE = AllowedRelayMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AllowedRelayMessageType_descriptor();
template<typename T>
inline const std::string& AllowedRelayMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AllowedRelayMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AllowedRelayMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AllowedRelayMessageType_descriptor(), enum_t_value);
}
inline bool AllowedRelayMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AllowedRelayMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AllowedRelayMessageType>(
    AllowedRelayMessageType_descriptor(), name, value);
}
enum AllowedBroadcastPushMessageType : int {
  ALLOW_BROADCAST_PUSH_PLACEHOLDER_DO_NOT_USE = 0,
  ALLOW_BROADCAST_PUSH_TRANSACTIONS = 12,
  AllowedBroadcastPushMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AllowedBroadcastPushMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AllowedBroadcastPushMessageType_IsValid(int value);
constexpr AllowedBroadcastPushMessageType AllowedBroadcastPushMessageType_MIN = ALLOW_BROADCAST_PUSH_PLACEHOLDER_DO_NOT_USE;
constexpr AllowedBroadcastPushMessageType AllowedBroadcastPushMessageType_MAX = ALLOW_BROADCAST_PUSH_TRANSACTIONS;
constexpr int AllowedBroadcastPushMessageType_ARRAYSIZE = AllowedBroadcastPushMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AllowedBroadcastPushMessageType_descriptor();
template<typename T>
inline const std::string& AllowedBroadcastPushMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AllowedBroadcastPushMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AllowedBroadcastPushMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AllowedBroadcastPushMessageType_descriptor(), enum_t_value);
}
inline bool AllowedBroadcastPushMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AllowedBroadcastPushMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AllowedBroadcastPushMessageType>(
    AllowedBroadcastPushMessageType_descriptor(), name, value);
}
enum AllowedBroadcastPullMessageType : int {
  ALLOW_BROADCAST_PULL_PLACEHOLDER_DO_NOT_USE = 0,
  AllowedBroadcastPullMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AllowedBroadcastPullMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AllowedBroadcastPullMessageType_IsValid(int value);
constexpr AllowedBroadcastPullMessageType AllowedBroadcastPullMessageType_MIN = ALLOW_BROADCAST_PULL_PLACEHOLDER_DO_NOT_USE;
constexpr AllowedBroadcastPullMessageType AllowedBroadcastPullMessageType_MAX = ALLOW_BROADCAST_PULL_PLACEHOLDER_DO_NOT_USE;
constexpr int AllowedBroadcastPullMessageType_ARRAYSIZE = AllowedBroadcastPullMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AllowedBroadcastPullMessageType_descriptor();
template<typename T>
inline const std::string& AllowedBroadcastPullMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AllowedBroadcastPullMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AllowedBroadcastPullMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AllowedBroadcastPullMessageType_descriptor(), enum_t_value);
}
inline bool AllowedBroadcastPullMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AllowedBroadcastPullMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AllowedBroadcastPullMessageType>(
    AllowedBroadcastPullMessageType_descriptor(), name, value);
}
enum AllowedBroadcastTreeMessageType : int {
  ALLOW_BROADCAST_TREE_PLACEHOLDER_DO_NOT_USE = 0,
  ALLOW_BROADCAST_TREE_TRANSACTIONS = 12,
  AllowedBroadcastTreeMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AllowedBroadcastTreeMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AllowedBroadcastTreeMessageType_IsValid(int value);
constexpr AllowedBroadcastTreeMessageType AllowedBroadcastTreeMessageType_MIN = ALLOW_BROADCAST_TREE_PLACEHOLDER_DO_NOT_USE;
constexpr AllowedBroadcastTreeMessageType AllowedBroadcastTreeMessageType_MAX = ALLOW_BROADCAST_TREE_TRANSACTIONS;
constexpr int AllowedBroadcastTreeMessageType_ARRAYSIZE = AllowedBroadcastTreeMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AllowedBroadcastTreeMessageType_descriptor();
template<typename T>
inline const std::string& AllowedBroadcastTreeMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AllowedBroadcastTreeMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AllowedBroadcastTreeMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AllowedBroadcastTreeMessageType_descriptor(), enum_t_value);
}
inline bool AllowedBroadcastTreeMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AllowedBroadcastTreeMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AllowedBroadcastTreeMessageType>(
    AllowedBroadcastTreeMessageType_descriptor(), name, value);
}
enum RequestTransactionType : int {
  REQUEST_FULL_TRANSACTION = 0,
  REQUEST_TRANSACTION_HASH = 1,
  REQUEST_TRANSACTION_SHORT_HASH = 2,
  RequestTransactionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RequestTransactionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RequestTransactionType_IsValid(int value);
constexpr RequestTransactionType RequestTransactionType_MIN = REQUEST_FULL_TRANSACTION;
constexpr RequestTransactionType RequestTransactionType_MAX = REQUEST_TRANSACTION_SHORT_HASH;
constexpr int RequestTransactionType_ARRAYSIZE = RequestTransactionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestTransactionType_descriptor();
template<typename T>
inline const std::string& RequestTransactionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RequestTransactionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RequestTransactionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RequestTransactionType_descriptor(), enum_t_value);
}
inline bool RequestTransactionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RequestTransactionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RequestTransactionType>(
    RequestTransactionType_descriptor(), name, value);
}
// ===================================================================

class UnsignedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.UnsignedMessage) */ {
 public:
  inline UnsignedMessage() : UnsignedMessage(nullptr) {}
  ~UnsignedMessage() override;
  explicit PROTOBUF_CONSTEXPR UnsignedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsignedMessage(const UnsignedMessage& from);
  UnsignedMessage(UnsignedMessage&& from) noexcept
    : UnsignedMessage() {
    *this = ::std::move(from);
  }

  inline UnsignedMessage& operator=(const UnsignedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsignedMessage& operator=(UnsignedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsignedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsignedMessage* internal_default_instance() {
    return reinterpret_cast<const UnsignedMessage*>(
               &_UnsignedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UnsignedMessage& a, UnsignedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsignedMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsignedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsignedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsignedMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsignedMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnsignedMessage& from) {
    UnsignedMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsignedMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.UnsignedMessage";
  }
  protected:
  explicit UnsignedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kMessageTypeFieldNumber = 1,
  };
  // bytes message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .pb.MessageType message_type = 1;
  void clear_message_type();
  ::pb::MessageType message_type() const;
  void set_message_type(::pb::MessageType value);
  private:
  ::pb::MessageType _internal_message_type() const;
  void _internal_set_message_type(::pb::MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:pb.UnsignedMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int message_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class SignedMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.SignedMessage) */ {
 public:
  inline SignedMessage() : SignedMessage(nullptr) {}
  ~SignedMessage() override;
  explicit PROTOBUF_CONSTEXPR SignedMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignedMessage(const SignedMessage& from);
  SignedMessage(SignedMessage&& from) noexcept
    : SignedMessage() {
    *this = ::std::move(from);
  }

  inline SignedMessage& operator=(const SignedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignedMessage& operator=(SignedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignedMessage* internal_default_instance() {
    return reinterpret_cast<const SignedMessage*>(
               &_SignedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SignedMessage& a, SignedMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SignedMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignedMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignedMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignedMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignedMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignedMessage& from) {
    SignedMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignedMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.SignedMessage";
  }
  protected:
  explicit SignedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kSignatureFieldNumber = 2,
  };
  // bytes message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bytes signature = 2;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // @@protoc_insertion_point(class_scope:pb.SignedMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class Vote final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Vote) */ {
 public:
  inline Vote() : Vote(nullptr) {}
  ~Vote() override;
  explicit PROTOBUF_CONSTEXPR Vote(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vote(const Vote& from);
  Vote(Vote&& from) noexcept
    : Vote() {
    *this = ::std::move(from);
  }

  inline Vote& operator=(const Vote& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vote& operator=(Vote&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vote& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vote* internal_default_instance() {
    return reinterpret_cast<const Vote*>(
               &_Vote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Vote& a, Vote& b) {
    a.Swap(&b);
  }
  inline void Swap(Vote* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vote* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vote>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vote& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vote& from) {
    Vote::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vote* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Vote";
  }
  protected:
  explicit Vote(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockHashFieldNumber = 2,
    kHeightFieldNumber = 1,
  };
  // bytes block_hash = 2;
  void clear_block_hash();
  const std::string& block_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_hash();
  PROTOBUF_NODISCARD std::string* release_block_hash();
  void set_allocated_block_hash(std::string* block_hash);
  private:
  const std::string& _internal_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_hash(const std::string& value);
  std::string* _internal_mutable_block_hash();
  public:

  // uint32 height = 1;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.Vote)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_;
    uint32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class IHaveBlockProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.IHaveBlockProposal) */ {
 public:
  inline IHaveBlockProposal() : IHaveBlockProposal(nullptr) {}
  ~IHaveBlockProposal() override;
  explicit PROTOBUF_CONSTEXPR IHaveBlockProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IHaveBlockProposal(const IHaveBlockProposal& from);
  IHaveBlockProposal(IHaveBlockProposal&& from) noexcept
    : IHaveBlockProposal() {
    *this = ::std::move(from);
  }

  inline IHaveBlockProposal& operator=(const IHaveBlockProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline IHaveBlockProposal& operator=(IHaveBlockProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IHaveBlockProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const IHaveBlockProposal* internal_default_instance() {
    return reinterpret_cast<const IHaveBlockProposal*>(
               &_IHaveBlockProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(IHaveBlockProposal& a, IHaveBlockProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(IHaveBlockProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IHaveBlockProposal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IHaveBlockProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IHaveBlockProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IHaveBlockProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IHaveBlockProposal& from) {
    IHaveBlockProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IHaveBlockProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.IHaveBlockProposal";
  }
  protected:
  explicit IHaveBlockProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockHashFieldNumber = 2,
    kHeightFieldNumber = 1,
  };
  // bytes block_hash = 2;
  void clear_block_hash();
  const std::string& block_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_hash();
  PROTOBUF_NODISCARD std::string* release_block_hash();
  void set_allocated_block_hash(std::string* block_hash);
  private:
  const std::string& _internal_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_hash(const std::string& value);
  std::string* _internal_mutable_block_hash();
  public:

  // uint32 height = 1;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.IHaveBlockProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_;
    uint32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class RequestBlockProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.RequestBlockProposal) */ {
 public:
  inline RequestBlockProposal() : RequestBlockProposal(nullptr) {}
  ~RequestBlockProposal() override;
  explicit PROTOBUF_CONSTEXPR RequestBlockProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestBlockProposal(const RequestBlockProposal& from);
  RequestBlockProposal(RequestBlockProposal&& from) noexcept
    : RequestBlockProposal() {
    *this = ::std::move(from);
  }

  inline RequestBlockProposal& operator=(const RequestBlockProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestBlockProposal& operator=(RequestBlockProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestBlockProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestBlockProposal* internal_default_instance() {
    return reinterpret_cast<const RequestBlockProposal*>(
               &_RequestBlockProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RequestBlockProposal& a, RequestBlockProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestBlockProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestBlockProposal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestBlockProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestBlockProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestBlockProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestBlockProposal& from) {
    RequestBlockProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestBlockProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.RequestBlockProposal";
  }
  protected:
  explicit RequestBlockProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockHashFieldNumber = 1,
    kShortHashSaltFieldNumber = 3,
    kTypeFieldNumber = 2,
    kShortHashSizeFieldNumber = 4,
  };
  // bytes block_hash = 1;
  void clear_block_hash();
  const std::string& block_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_hash();
  PROTOBUF_NODISCARD std::string* release_block_hash();
  void set_allocated_block_hash(std::string* block_hash);
  private:
  const std::string& _internal_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_hash(const std::string& value);
  std::string* _internal_mutable_block_hash();
  public:

  // bytes short_hash_salt = 3;
  void clear_short_hash_salt();
  const std::string& short_hash_salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_short_hash_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_short_hash_salt();
  PROTOBUF_NODISCARD std::string* release_short_hash_salt();
  void set_allocated_short_hash_salt(std::string* short_hash_salt);
  private:
  const std::string& _internal_short_hash_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_short_hash_salt(const std::string& value);
  std::string* _internal_mutable_short_hash_salt();
  public:

  // .pb.RequestTransactionType type = 2;
  void clear_type();
  ::pb::RequestTransactionType type() const;
  void set_type(::pb::RequestTransactionType value);
  private:
  ::pb::RequestTransactionType _internal_type() const;
  void _internal_set_type(::pb::RequestTransactionType value);
  public:

  // uint32 short_hash_size = 4;
  void clear_short_hash_size();
  uint32_t short_hash_size() const;
  void set_short_hash_size(uint32_t value);
  private:
  uint32_t _internal_short_hash_size() const;
  void _internal_set_short_hash_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.RequestBlockProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr short_hash_salt_;
    int type_;
    uint32_t short_hash_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class RequestBlockProposalReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.RequestBlockProposalReply) */ {
 public:
  inline RequestBlockProposalReply() : RequestBlockProposalReply(nullptr) {}
  ~RequestBlockProposalReply() override;
  explicit PROTOBUF_CONSTEXPR RequestBlockProposalReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestBlockProposalReply(const RequestBlockProposalReply& from);
  RequestBlockProposalReply(RequestBlockProposalReply&& from) noexcept
    : RequestBlockProposalReply() {
    *this = ::std::move(from);
  }

  inline RequestBlockProposalReply& operator=(const RequestBlockProposalReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestBlockProposalReply& operator=(RequestBlockProposalReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestBlockProposalReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestBlockProposalReply* internal_default_instance() {
    return reinterpret_cast<const RequestBlockProposalReply*>(
               &_RequestBlockProposalReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RequestBlockProposalReply& a, RequestBlockProposalReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestBlockProposalReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestBlockProposalReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestBlockProposalReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestBlockProposalReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestBlockProposalReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestBlockProposalReply& from) {
    RequestBlockProposalReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestBlockProposalReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.RequestBlockProposalReply";
  }
  protected:
  explicit RequestBlockProposalReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionsHashFieldNumber = 2,
    kBlockFieldNumber = 1,
  };
  // repeated bytes transactions_hash = 2;
  int transactions_hash_size() const;
  private:
  int _internal_transactions_hash_size() const;
  public:
  void clear_transactions_hash();
  const std::string& transactions_hash(int index) const;
  std::string* mutable_transactions_hash(int index);
  void set_transactions_hash(int index, const std::string& value);
  void set_transactions_hash(int index, std::string&& value);
  void set_transactions_hash(int index, const char* value);
  void set_transactions_hash(int index, const void* value, size_t size);
  std::string* add_transactions_hash();
  void add_transactions_hash(const std::string& value);
  void add_transactions_hash(std::string&& value);
  void add_transactions_hash(const char* value);
  void add_transactions_hash(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& transactions_hash() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_transactions_hash();
  private:
  const std::string& _internal_transactions_hash(int index) const;
  std::string* _internal_add_transactions_hash();
  public:

  // .pb.Block block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::pb::Block& block() const;
  PROTOBUF_NODISCARD ::pb::Block* release_block();
  ::pb::Block* mutable_block();
  void set_allocated_block(::pb::Block* block);
  private:
  const ::pb::Block& _internal_block() const;
  ::pb::Block* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::pb::Block* block);
  ::pb::Block* unsafe_arena_release_block();

  // @@protoc_insertion_point(class_scope:pb.RequestBlockProposalReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> transactions_hash_;
    ::pb::Block* block_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class RequestProposalTransactions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.RequestProposalTransactions) */ {
 public:
  inline RequestProposalTransactions() : RequestProposalTransactions(nullptr) {}
  ~RequestProposalTransactions() override;
  explicit PROTOBUF_CONSTEXPR RequestProposalTransactions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestProposalTransactions(const RequestProposalTransactions& from);
  RequestProposalTransactions(RequestProposalTransactions&& from) noexcept
    : RequestProposalTransactions() {
    *this = ::std::move(from);
  }

  inline RequestProposalTransactions& operator=(const RequestProposalTransactions& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestProposalTransactions& operator=(RequestProposalTransactions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestProposalTransactions& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestProposalTransactions* internal_default_instance() {
    return reinterpret_cast<const RequestProposalTransactions*>(
               &_RequestProposalTransactions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RequestProposalTransactions& a, RequestProposalTransactions& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestProposalTransactions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestProposalTransactions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestProposalTransactions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestProposalTransactions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestProposalTransactions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestProposalTransactions& from) {
    RequestProposalTransactions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestProposalTransactions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.RequestProposalTransactions";
  }
  protected:
  explicit RequestProposalTransactions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionsHashFieldNumber = 5,
    kBlockHashFieldNumber = 1,
    kShortHashSaltFieldNumber = 3,
    kTypeFieldNumber = 2,
    kShortHashSizeFieldNumber = 4,
  };
  // repeated bytes transactions_hash = 5;
  int transactions_hash_size() const;
  private:
  int _internal_transactions_hash_size() const;
  public:
  void clear_transactions_hash();
  const std::string& transactions_hash(int index) const;
  std::string* mutable_transactions_hash(int index);
  void set_transactions_hash(int index, const std::string& value);
  void set_transactions_hash(int index, std::string&& value);
  void set_transactions_hash(int index, const char* value);
  void set_transactions_hash(int index, const void* value, size_t size);
  std::string* add_transactions_hash();
  void add_transactions_hash(const std::string& value);
  void add_transactions_hash(std::string&& value);
  void add_transactions_hash(const char* value);
  void add_transactions_hash(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& transactions_hash() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_transactions_hash();
  private:
  const std::string& _internal_transactions_hash(int index) const;
  std::string* _internal_add_transactions_hash();
  public:

  // bytes block_hash = 1;
  void clear_block_hash();
  const std::string& block_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_hash();
  PROTOBUF_NODISCARD std::string* release_block_hash();
  void set_allocated_block_hash(std::string* block_hash);
  private:
  const std::string& _internal_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_hash(const std::string& value);
  std::string* _internal_mutable_block_hash();
  public:

  // bytes short_hash_salt = 3;
  void clear_short_hash_salt();
  const std::string& short_hash_salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_short_hash_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_short_hash_salt();
  PROTOBUF_NODISCARD std::string* release_short_hash_salt();
  void set_allocated_short_hash_salt(std::string* short_hash_salt);
  private:
  const std::string& _internal_short_hash_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_short_hash_salt(const std::string& value);
  std::string* _internal_mutable_short_hash_salt();
  public:

  // .pb.RequestTransactionType type = 2;
  void clear_type();
  ::pb::RequestTransactionType type() const;
  void set_type(::pb::RequestTransactionType value);
  private:
  ::pb::RequestTransactionType _internal_type() const;
  void _internal_set_type(::pb::RequestTransactionType value);
  public:

  // uint32 short_hash_size = 4;
  void clear_short_hash_size();
  uint32_t short_hash_size() const;
  void set_short_hash_size(uint32_t value);
  private:
  uint32_t _internal_short_hash_size() const;
  void _internal_set_short_hash_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.RequestProposalTransactions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> transactions_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr short_hash_salt_;
    int type_;
    uint32_t short_hash_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class RequestProposalTransactionsReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.RequestProposalTransactionsReply) */ {
 public:
  inline RequestProposalTransactionsReply() : RequestProposalTransactionsReply(nullptr) {}
  ~RequestProposalTransactionsReply() override;
  explicit PROTOBUF_CONSTEXPR RequestProposalTransactionsReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestProposalTransactionsReply(const RequestProposalTransactionsReply& from);
  RequestProposalTransactionsReply(RequestProposalTransactionsReply&& from) noexcept
    : RequestProposalTransactionsReply() {
    *this = ::std::move(from);
  }

  inline RequestProposalTransactionsReply& operator=(const RequestProposalTransactionsReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestProposalTransactionsReply& operator=(RequestProposalTransactionsReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestProposalTransactionsReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestProposalTransactionsReply* internal_default_instance() {
    return reinterpret_cast<const RequestProposalTransactionsReply*>(
               &_RequestProposalTransactionsReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RequestProposalTransactionsReply& a, RequestProposalTransactionsReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestProposalTransactionsReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestProposalTransactionsReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestProposalTransactionsReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestProposalTransactionsReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestProposalTransactionsReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestProposalTransactionsReply& from) {
    RequestProposalTransactionsReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestProposalTransactionsReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.RequestProposalTransactionsReply";
  }
  protected:
  explicit RequestProposalTransactionsReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionsFieldNumber = 1,
  };
  // repeated .pb.Transaction transactions = 1;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;
  public:
  void clear_transactions();
  ::pb::Transaction* mutable_transactions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Transaction >*
      mutable_transactions();
  private:
  const ::pb::Transaction& _internal_transactions(int index) const;
  ::pb::Transaction* _internal_add_transactions();
  public:
  const ::pb::Transaction& transactions(int index) const;
  ::pb::Transaction* add_transactions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Transaction >&
      transactions() const;

  // @@protoc_insertion_point(class_scope:pb.RequestProposalTransactionsReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Transaction > transactions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class GetConsensusState final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:pb.GetConsensusState) */ {
 public:
  inline GetConsensusState() : GetConsensusState(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetConsensusState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConsensusState(const GetConsensusState& from);
  GetConsensusState(GetConsensusState&& from) noexcept
    : GetConsensusState() {
    *this = ::std::move(from);
  }

  inline GetConsensusState& operator=(const GetConsensusState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConsensusState& operator=(GetConsensusState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConsensusState& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConsensusState* internal_default_instance() {
    return reinterpret_cast<const GetConsensusState*>(
               &_GetConsensusState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetConsensusState& a, GetConsensusState& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConsensusState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConsensusState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConsensusState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConsensusState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetConsensusState& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetConsensusState& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.GetConsensusState";
  }
  protected:
  explicit GetConsensusState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pb.GetConsensusState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class GetConsensusStateReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.GetConsensusStateReply) */ {
 public:
  inline GetConsensusStateReply() : GetConsensusStateReply(nullptr) {}
  ~GetConsensusStateReply() override;
  explicit PROTOBUF_CONSTEXPR GetConsensusStateReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConsensusStateReply(const GetConsensusStateReply& from);
  GetConsensusStateReply(GetConsensusStateReply&& from) noexcept
    : GetConsensusStateReply() {
    *this = ::std::move(from);
  }

  inline GetConsensusStateReply& operator=(const GetConsensusStateReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConsensusStateReply& operator=(GetConsensusStateReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConsensusStateReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConsensusStateReply* internal_default_instance() {
    return reinterpret_cast<const GetConsensusStateReply*>(
               &_GetConsensusStateReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetConsensusStateReply& a, GetConsensusStateReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConsensusStateReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConsensusStateReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConsensusStateReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConsensusStateReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConsensusStateReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConsensusStateReply& from) {
    GetConsensusStateReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConsensusStateReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.GetConsensusStateReply";
  }
  protected:
  explicit GetConsensusStateReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLedgerBlockHashFieldNumber = 2,
    kLedgerHeightFieldNumber = 1,
    kConsensusHeightFieldNumber = 3,
    kSyncStateFieldNumber = 4,
    kMinVerifiableHeightFieldNumber = 5,
  };
  // bytes ledger_block_hash = 2;
  void clear_ledger_block_hash();
  const std::string& ledger_block_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ledger_block_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ledger_block_hash();
  PROTOBUF_NODISCARD std::string* release_ledger_block_hash();
  void set_allocated_ledger_block_hash(std::string* ledger_block_hash);
  private:
  const std::string& _internal_ledger_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ledger_block_hash(const std::string& value);
  std::string* _internal_mutable_ledger_block_hash();
  public:

  // uint32 ledger_height = 1;
  void clear_ledger_height();
  uint32_t ledger_height() const;
  void set_ledger_height(uint32_t value);
  private:
  uint32_t _internal_ledger_height() const;
  void _internal_set_ledger_height(uint32_t value);
  public:

  // uint32 consensus_height = 3;
  void clear_consensus_height();
  uint32_t consensus_height() const;
  void set_consensus_height(uint32_t value);
  private:
  uint32_t _internal_consensus_height() const;
  void _internal_set_consensus_height(uint32_t value);
  public:

  // .pb.SyncState sync_state = 4;
  void clear_sync_state();
  ::pb::SyncState sync_state() const;
  void set_sync_state(::pb::SyncState value);
  private:
  ::pb::SyncState _internal_sync_state() const;
  void _internal_set_sync_state(::pb::SyncState value);
  public:

  // uint32 min_verifiable_height = 5;
  void clear_min_verifiable_height();
  uint32_t min_verifiable_height() const;
  void set_min_verifiable_height(uint32_t value);
  private:
  uint32_t _internal_min_verifiable_height() const;
  void _internal_set_min_verifiable_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.GetConsensusStateReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ledger_block_hash_;
    uint32_t ledger_height_;
    uint32_t consensus_height_;
    int sync_state_;
    uint32_t min_verifiable_height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class GetBlockHeaders final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.GetBlockHeaders) */ {
 public:
  inline GetBlockHeaders() : GetBlockHeaders(nullptr) {}
  ~GetBlockHeaders() override;
  explicit PROTOBUF_CONSTEXPR GetBlockHeaders(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockHeaders(const GetBlockHeaders& from);
  GetBlockHeaders(GetBlockHeaders&& from) noexcept
    : GetBlockHeaders() {
    *this = ::std::move(from);
  }

  inline GetBlockHeaders& operator=(const GetBlockHeaders& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockHeaders& operator=(GetBlockHeaders&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockHeaders& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockHeaders* internal_default_instance() {
    return reinterpret_cast<const GetBlockHeaders*>(
               &_GetBlockHeaders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetBlockHeaders& a, GetBlockHeaders& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockHeaders* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockHeaders* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlockHeaders* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBlockHeaders>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockHeaders& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBlockHeaders& from) {
    GetBlockHeaders::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockHeaders* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.GetBlockHeaders";
  }
  protected:
  explicit GetBlockHeaders(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartHeightFieldNumber = 1,
    kEndHeightFieldNumber = 2,
  };
  // uint32 start_height = 1;
  void clear_start_height();
  uint32_t start_height() const;
  void set_start_height(uint32_t value);
  private:
  uint32_t _internal_start_height() const;
  void _internal_set_start_height(uint32_t value);
  public:

  // uint32 end_height = 2;
  void clear_end_height();
  uint32_t end_height() const;
  void set_end_height(uint32_t value);
  private:
  uint32_t _internal_end_height() const;
  void _internal_set_end_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.GetBlockHeaders)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t start_height_;
    uint32_t end_height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class GetBlockHeadersReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.GetBlockHeadersReply) */ {
 public:
  inline GetBlockHeadersReply() : GetBlockHeadersReply(nullptr) {}
  ~GetBlockHeadersReply() override;
  explicit PROTOBUF_CONSTEXPR GetBlockHeadersReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockHeadersReply(const GetBlockHeadersReply& from);
  GetBlockHeadersReply(GetBlockHeadersReply&& from) noexcept
    : GetBlockHeadersReply() {
    *this = ::std::move(from);
  }

  inline GetBlockHeadersReply& operator=(const GetBlockHeadersReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockHeadersReply& operator=(GetBlockHeadersReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockHeadersReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockHeadersReply* internal_default_instance() {
    return reinterpret_cast<const GetBlockHeadersReply*>(
               &_GetBlockHeadersReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetBlockHeadersReply& a, GetBlockHeadersReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockHeadersReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockHeadersReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlockHeadersReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBlockHeadersReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockHeadersReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBlockHeadersReply& from) {
    GetBlockHeadersReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockHeadersReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.GetBlockHeadersReply";
  }
  protected:
  explicit GetBlockHeadersReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockHeadersFieldNumber = 1,
  };
  // repeated .pb.Header block_headers = 1;
  int block_headers_size() const;
  private:
  int _internal_block_headers_size() const;
  public:
  void clear_block_headers();
  ::pb::Header* mutable_block_headers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Header >*
      mutable_block_headers();
  private:
  const ::pb::Header& _internal_block_headers(int index) const;
  ::pb::Header* _internal_add_block_headers();
  public:
  const ::pb::Header& block_headers(int index) const;
  ::pb::Header* add_block_headers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Header >&
      block_headers() const;

  // @@protoc_insertion_point(class_scope:pb.GetBlockHeadersReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Header > block_headers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class GetBlocks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.GetBlocks) */ {
 public:
  inline GetBlocks() : GetBlocks(nullptr) {}
  ~GetBlocks() override;
  explicit PROTOBUF_CONSTEXPR GetBlocks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlocks(const GetBlocks& from);
  GetBlocks(GetBlocks&& from) noexcept
    : GetBlocks() {
    *this = ::std::move(from);
  }

  inline GetBlocks& operator=(const GetBlocks& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlocks& operator=(GetBlocks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlocks& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlocks* internal_default_instance() {
    return reinterpret_cast<const GetBlocks*>(
               &_GetBlocks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetBlocks& a, GetBlocks& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlocks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlocks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlocks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBlocks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlocks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBlocks& from) {
    GetBlocks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlocks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.GetBlocks";
  }
  protected:
  explicit GetBlocks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartHeightFieldNumber = 1,
    kEndHeightFieldNumber = 2,
  };
  // uint32 start_height = 1;
  void clear_start_height();
  uint32_t start_height() const;
  void set_start_height(uint32_t value);
  private:
  uint32_t _internal_start_height() const;
  void _internal_set_start_height(uint32_t value);
  public:

  // uint32 end_height = 2;
  void clear_end_height();
  uint32_t end_height() const;
  void set_end_height(uint32_t value);
  private:
  uint32_t _internal_end_height() const;
  void _internal_set_end_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.GetBlocks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t start_height_;
    uint32_t end_height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class GetBlocksReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.GetBlocksReply) */ {
 public:
  inline GetBlocksReply() : GetBlocksReply(nullptr) {}
  ~GetBlocksReply() override;
  explicit PROTOBUF_CONSTEXPR GetBlocksReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlocksReply(const GetBlocksReply& from);
  GetBlocksReply(GetBlocksReply&& from) noexcept
    : GetBlocksReply() {
    *this = ::std::move(from);
  }

  inline GetBlocksReply& operator=(const GetBlocksReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlocksReply& operator=(GetBlocksReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlocksReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlocksReply* internal_default_instance() {
    return reinterpret_cast<const GetBlocksReply*>(
               &_GetBlocksReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetBlocksReply& a, GetBlocksReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlocksReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlocksReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlocksReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBlocksReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlocksReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBlocksReply& from) {
    GetBlocksReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlocksReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.GetBlocksReply";
  }
  protected:
  explicit GetBlocksReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFieldNumber = 1,
  };
  // repeated .pb.Block blocks = 1;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  ::pb::Block* mutable_blocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Block >*
      mutable_blocks();
  private:
  const ::pb::Block& _internal_blocks(int index) const;
  ::pb::Block* _internal_add_blocks();
  public:
  const ::pb::Block& blocks(int index) const;
  ::pb::Block* add_blocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Block >&
      blocks() const;

  // @@protoc_insertion_point(class_scope:pb.GetBlocksReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Block > blocks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class StateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.StateRequest) */ {
 public:
  inline StateRequest() : StateRequest(nullptr) {}
  ~StateRequest() override;
  explicit PROTOBUF_CONSTEXPR StateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StateRequest(const StateRequest& from);
  StateRequest(StateRequest&& from) noexcept
    : StateRequest() {
    *this = ::std::move(from);
  }

  inline StateRequest& operator=(const StateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateRequest& operator=(StateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateRequest* internal_default_instance() {
    return reinterpret_cast<const StateRequest*>(
               &_StateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(StateRequest& a, StateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StateRequest& from) {
    StateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.StateRequest";
  }
  protected:
  explicit StateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
  };
  // bytes hash = 1;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // @@protoc_insertion_point(class_scope:pb.StateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class StateNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.StateNode) */ {
 public:
  inline StateNode() : StateNode(nullptr) {}
  ~StateNode() override;
  explicit PROTOBUF_CONSTEXPR StateNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StateNode(const StateNode& from);
  StateNode(StateNode&& from) noexcept
    : StateNode() {
    *this = ::std::move(from);
  }

  inline StateNode& operator=(const StateNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateNode& operator=(StateNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateNode* internal_default_instance() {
    return reinterpret_cast<const StateNode*>(
               &_StateNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(StateNode& a, StateNode& b) {
    a.Swap(&b);
  }
  inline void Swap(StateNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StateNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StateNode& from) {
    StateNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.StateNode";
  }
  protected:
  explicit StateNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 1,
  };
  // bytes node = 1;
  void clear_node();
  const std::string& node() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node();
  PROTOBUF_NODISCARD std::string* release_node();
  void set_allocated_node(std::string* node);
  private:
  const std::string& _internal_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node(const std::string& value);
  std::string* _internal_mutable_node();
  public:

  // @@protoc_insertion_point(class_scope:pb.StateNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class GetStates final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.GetStates) */ {
 public:
  inline GetStates() : GetStates(nullptr) {}
  ~GetStates() override;
  explicit PROTOBUF_CONSTEXPR GetStates(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStates(const GetStates& from);
  GetStates(GetStates&& from) noexcept
    : GetStates() {
    *this = ::std::move(from);
  }

  inline GetStates& operator=(const GetStates& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStates& operator=(GetStates&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStates& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStates* internal_default_instance() {
    return reinterpret_cast<const GetStates*>(
               &_GetStates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetStates& a, GetStates& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStates* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStates* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStates* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStates>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStates& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetStates& from) {
    GetStates::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStates* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.GetStates";
  }
  protected:
  explicit GetStates(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqsFieldNumber = 1,
  };
  // repeated .pb.StateRequest reqs = 1;
  int reqs_size() const;
  private:
  int _internal_reqs_size() const;
  public:
  void clear_reqs();
  ::pb::StateRequest* mutable_reqs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::StateRequest >*
      mutable_reqs();
  private:
  const ::pb::StateRequest& _internal_reqs(int index) const;
  ::pb::StateRequest* _internal_add_reqs();
  public:
  const ::pb::StateRequest& reqs(int index) const;
  ::pb::StateRequest* add_reqs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::StateRequest >&
      reqs() const;

  // @@protoc_insertion_point(class_scope:pb.GetStates)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::StateRequest > reqs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class GetStatesReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.GetStatesReply) */ {
 public:
  inline GetStatesReply() : GetStatesReply(nullptr) {}
  ~GetStatesReply() override;
  explicit PROTOBUF_CONSTEXPR GetStatesReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStatesReply(const GetStatesReply& from);
  GetStatesReply(GetStatesReply&& from) noexcept
    : GetStatesReply() {
    *this = ::std::move(from);
  }

  inline GetStatesReply& operator=(const GetStatesReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatesReply& operator=(GetStatesReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStatesReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStatesReply* internal_default_instance() {
    return reinterpret_cast<const GetStatesReply*>(
               &_GetStatesReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetStatesReply& a, GetStatesReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStatesReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatesReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStatesReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStatesReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStatesReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetStatesReply& from) {
    GetStatesReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStatesReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.GetStatesReply";
  }
  protected:
  explicit GetStatesReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
  };
  // repeated .pb.StateNode nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::pb::StateNode* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::StateNode >*
      mutable_nodes();
  private:
  const ::pb::StateNode& _internal_nodes(int index) const;
  ::pb::StateNode* _internal_add_nodes();
  public:
  const ::pb::StateNode& nodes(int index) const;
  ::pb::StateNode* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::StateNode >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:pb.GetStatesReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::StateNode > nodes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class Relay final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Relay) */ {
 public:
  inline Relay() : Relay(nullptr) {}
  ~Relay() override;
  explicit PROTOBUF_CONSTEXPR Relay(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Relay(const Relay& from);
  Relay(Relay&& from) noexcept
    : Relay() {
    *this = ::std::move(from);
  }

  inline Relay& operator=(const Relay& from) {
    CopyFrom(from);
    return *this;
  }
  inline Relay& operator=(Relay&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Relay& default_instance() {
    return *internal_default_instance();
  }
  static inline const Relay* internal_default_instance() {
    return reinterpret_cast<const Relay*>(
               &_Relay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Relay& a, Relay& b) {
    a.Swap(&b);
  }
  inline void Swap(Relay* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Relay* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Relay* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Relay>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Relay& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Relay& from) {
    Relay::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Relay* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Relay";
  }
  protected:
  explicit Relay(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcIdentifierFieldNumber = 1,
    kDestIdFieldNumber = 2,
    kPayloadFieldNumber = 3,
    kSrcPubkeyFieldNumber = 6,
    kBlockHashFieldNumber = 7,
    kLastHashFieldNumber = 8,
    kMaxHoldingSecondsFieldNumber = 5,
    kSigChainLenFieldNumber = 9,
  };
  // string src_identifier = 1;
  void clear_src_identifier();
  const std::string& src_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_identifier();
  PROTOBUF_NODISCARD std::string* release_src_identifier();
  void set_allocated_src_identifier(std::string* src_identifier);
  private:
  const std::string& _internal_src_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_identifier(const std::string& value);
  std::string* _internal_mutable_src_identifier();
  public:

  // bytes dest_id = 2;
  void clear_dest_id();
  const std::string& dest_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dest_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dest_id();
  PROTOBUF_NODISCARD std::string* release_dest_id();
  void set_allocated_dest_id(std::string* dest_id);
  private:
  const std::string& _internal_dest_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dest_id(const std::string& value);
  std::string* _internal_mutable_dest_id();
  public:

  // bytes payload = 3;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // bytes src_pubkey = 6;
  void clear_src_pubkey();
  const std::string& src_pubkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_pubkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_pubkey();
  PROTOBUF_NODISCARD std::string* release_src_pubkey();
  void set_allocated_src_pubkey(std::string* src_pubkey);
  private:
  const std::string& _internal_src_pubkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_pubkey(const std::string& value);
  std::string* _internal_mutable_src_pubkey();
  public:

  // bytes block_hash = 7;
  void clear_block_hash();
  const std::string& block_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_hash();
  PROTOBUF_NODISCARD std::string* release_block_hash();
  void set_allocated_block_hash(std::string* block_hash);
  private:
  const std::string& _internal_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_hash(const std::string& value);
  std::string* _internal_mutable_block_hash();
  public:

  // bytes last_hash = 8;
  void clear_last_hash();
  const std::string& last_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_hash();
  PROTOBUF_NODISCARD std::string* release_last_hash();
  void set_allocated_last_hash(std::string* last_hash);
  private:
  const std::string& _internal_last_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_hash(const std::string& value);
  std::string* _internal_mutable_last_hash();
  public:

  // uint32 max_holding_seconds = 5;
  void clear_max_holding_seconds();
  uint32_t max_holding_seconds() const;
  void set_max_holding_seconds(uint32_t value);
  private:
  uint32_t _internal_max_holding_seconds() const;
  void _internal_set_max_holding_seconds(uint32_t value);
  public:

  // uint32 sig_chain_len = 9;
  void clear_sig_chain_len();
  uint32_t sig_chain_len() const;
  void set_sig_chain_len(uint32_t value);
  private:
  uint32_t _internal_sig_chain_len() const;
  void _internal_set_sig_chain_len(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.Relay)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_identifier_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dest_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_pubkey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_hash_;
    uint32_t max_holding_seconds_;
    uint32_t sig_chain_len_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class Transactions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Transactions) */ {
 public:
  inline Transactions() : Transactions(nullptr) {}
  ~Transactions() override;
  explicit PROTOBUF_CONSTEXPR Transactions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transactions(const Transactions& from);
  Transactions(Transactions&& from) noexcept
    : Transactions() {
    *this = ::std::move(from);
  }

  inline Transactions& operator=(const Transactions& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transactions& operator=(Transactions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transactions& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transactions* internal_default_instance() {
    return reinterpret_cast<const Transactions*>(
               &_Transactions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Transactions& a, Transactions& b) {
    a.Swap(&b);
  }
  inline void Swap(Transactions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transactions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transactions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transactions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transactions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Transactions& from) {
    Transactions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transactions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Transactions";
  }
  protected:
  explicit Transactions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionsFieldNumber = 1,
  };
  // repeated .pb.Transaction transactions = 1;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;
  public:
  void clear_transactions();
  ::pb::Transaction* mutable_transactions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Transaction >*
      mutable_transactions();
  private:
  const ::pb::Transaction& _internal_transactions(int index) const;
  ::pb::Transaction* _internal_add_transactions();
  public:
  const ::pb::Transaction& transactions(int index) const;
  ::pb::Transaction* add_transactions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Transaction >&
      transactions() const;

  // @@protoc_insertion_point(class_scope:pb.Transactions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Transaction > transactions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class BacktrackSignatureChain final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.BacktrackSignatureChain) */ {
 public:
  inline BacktrackSignatureChain() : BacktrackSignatureChain(nullptr) {}
  ~BacktrackSignatureChain() override;
  explicit PROTOBUF_CONSTEXPR BacktrackSignatureChain(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BacktrackSignatureChain(const BacktrackSignatureChain& from);
  BacktrackSignatureChain(BacktrackSignatureChain&& from) noexcept
    : BacktrackSignatureChain() {
    *this = ::std::move(from);
  }

  inline BacktrackSignatureChain& operator=(const BacktrackSignatureChain& from) {
    CopyFrom(from);
    return *this;
  }
  inline BacktrackSignatureChain& operator=(BacktrackSignatureChain&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BacktrackSignatureChain& default_instance() {
    return *internal_default_instance();
  }
  static inline const BacktrackSignatureChain* internal_default_instance() {
    return reinterpret_cast<const BacktrackSignatureChain*>(
               &_BacktrackSignatureChain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(BacktrackSignatureChain& a, BacktrackSignatureChain& b) {
    a.Swap(&b);
  }
  inline void Swap(BacktrackSignatureChain* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BacktrackSignatureChain* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BacktrackSignatureChain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BacktrackSignatureChain>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BacktrackSignatureChain& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BacktrackSignatureChain& from) {
    BacktrackSignatureChain::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BacktrackSignatureChain* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.BacktrackSignatureChain";
  }
  protected:
  explicit BacktrackSignatureChain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSigChainElemsFieldNumber = 1,
    kHashFieldNumber = 2,
  };
  // repeated .pb.SigChainElem sig_chain_elems = 1;
  int sig_chain_elems_size() const;
  private:
  int _internal_sig_chain_elems_size() const;
  public:
  void clear_sig_chain_elems();
  ::pb::SigChainElem* mutable_sig_chain_elems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::SigChainElem >*
      mutable_sig_chain_elems();
  private:
  const ::pb::SigChainElem& _internal_sig_chain_elems(int index) const;
  ::pb::SigChainElem* _internal_add_sig_chain_elems();
  public:
  const ::pb::SigChainElem& sig_chain_elems(int index) const;
  ::pb::SigChainElem* add_sig_chain_elems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::SigChainElem >&
      sig_chain_elems() const;

  // bytes hash = 2;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // @@protoc_insertion_point(class_scope:pb.BacktrackSignatureChain)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::SigChainElem > sig_chain_elems_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class IHaveSignatureChainTransaction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.IHaveSignatureChainTransaction) */ {
 public:
  inline IHaveSignatureChainTransaction() : IHaveSignatureChainTransaction(nullptr) {}
  ~IHaveSignatureChainTransaction() override;
  explicit PROTOBUF_CONSTEXPR IHaveSignatureChainTransaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IHaveSignatureChainTransaction(const IHaveSignatureChainTransaction& from);
  IHaveSignatureChainTransaction(IHaveSignatureChainTransaction&& from) noexcept
    : IHaveSignatureChainTransaction() {
    *this = ::std::move(from);
  }

  inline IHaveSignatureChainTransaction& operator=(const IHaveSignatureChainTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline IHaveSignatureChainTransaction& operator=(IHaveSignatureChainTransaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IHaveSignatureChainTransaction& default_instance() {
    return *internal_default_instance();
  }
  static inline const IHaveSignatureChainTransaction* internal_default_instance() {
    return reinterpret_cast<const IHaveSignatureChainTransaction*>(
               &_IHaveSignatureChainTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(IHaveSignatureChainTransaction& a, IHaveSignatureChainTransaction& b) {
    a.Swap(&b);
  }
  inline void Swap(IHaveSignatureChainTransaction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IHaveSignatureChainTransaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IHaveSignatureChainTransaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IHaveSignatureChainTransaction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IHaveSignatureChainTransaction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IHaveSignatureChainTransaction& from) {
    IHaveSignatureChainTransaction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IHaveSignatureChainTransaction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.IHaveSignatureChainTransaction";
  }
  protected:
  explicit IHaveSignatureChainTransaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureHashFieldNumber = 2,
    kHeightFieldNumber = 1,
  };
  // bytes signature_hash = 2;
  void clear_signature_hash();
  const std::string& signature_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature_hash();
  PROTOBUF_NODISCARD std::string* release_signature_hash();
  void set_allocated_signature_hash(std::string* signature_hash);
  private:
  const std::string& _internal_signature_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature_hash(const std::string& value);
  std::string* _internal_mutable_signature_hash();
  public:

  // uint32 height = 1;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.IHaveSignatureChainTransaction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_hash_;
    uint32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class RequestSignatureChainTransaction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.RequestSignatureChainTransaction) */ {
 public:
  inline RequestSignatureChainTransaction() : RequestSignatureChainTransaction(nullptr) {}
  ~RequestSignatureChainTransaction() override;
  explicit PROTOBUF_CONSTEXPR RequestSignatureChainTransaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestSignatureChainTransaction(const RequestSignatureChainTransaction& from);
  RequestSignatureChainTransaction(RequestSignatureChainTransaction&& from) noexcept
    : RequestSignatureChainTransaction() {
    *this = ::std::move(from);
  }

  inline RequestSignatureChainTransaction& operator=(const RequestSignatureChainTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestSignatureChainTransaction& operator=(RequestSignatureChainTransaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestSignatureChainTransaction& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestSignatureChainTransaction* internal_default_instance() {
    return reinterpret_cast<const RequestSignatureChainTransaction*>(
               &_RequestSignatureChainTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(RequestSignatureChainTransaction& a, RequestSignatureChainTransaction& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestSignatureChainTransaction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestSignatureChainTransaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestSignatureChainTransaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestSignatureChainTransaction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestSignatureChainTransaction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestSignatureChainTransaction& from) {
    RequestSignatureChainTransaction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestSignatureChainTransaction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.RequestSignatureChainTransaction";
  }
  protected:
  explicit RequestSignatureChainTransaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureHashFieldNumber = 1,
  };
  // bytes signature_hash = 1;
  void clear_signature_hash();
  const std::string& signature_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature_hash();
  PROTOBUF_NODISCARD std::string* release_signature_hash();
  void set_allocated_signature_hash(std::string* signature_hash);
  private:
  const std::string& _internal_signature_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature_hash(const std::string& value);
  std::string* _internal_mutable_signature_hash();
  public:

  // @@protoc_insertion_point(class_scope:pb.RequestSignatureChainTransaction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class RequestSignatureChainTransactionReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.RequestSignatureChainTransactionReply) */ {
 public:
  inline RequestSignatureChainTransactionReply() : RequestSignatureChainTransactionReply(nullptr) {}
  ~RequestSignatureChainTransactionReply() override;
  explicit PROTOBUF_CONSTEXPR RequestSignatureChainTransactionReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestSignatureChainTransactionReply(const RequestSignatureChainTransactionReply& from);
  RequestSignatureChainTransactionReply(RequestSignatureChainTransactionReply&& from) noexcept
    : RequestSignatureChainTransactionReply() {
    *this = ::std::move(from);
  }

  inline RequestSignatureChainTransactionReply& operator=(const RequestSignatureChainTransactionReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestSignatureChainTransactionReply& operator=(RequestSignatureChainTransactionReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestSignatureChainTransactionReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestSignatureChainTransactionReply* internal_default_instance() {
    return reinterpret_cast<const RequestSignatureChainTransactionReply*>(
               &_RequestSignatureChainTransactionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(RequestSignatureChainTransactionReply& a, RequestSignatureChainTransactionReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestSignatureChainTransactionReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestSignatureChainTransactionReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestSignatureChainTransactionReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestSignatureChainTransactionReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestSignatureChainTransactionReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestSignatureChainTransactionReply& from) {
    RequestSignatureChainTransactionReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestSignatureChainTransactionReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.RequestSignatureChainTransactionReply";
  }
  protected:
  explicit RequestSignatureChainTransactionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionFieldNumber = 1,
  };
  // .pb.Transaction transaction = 1;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::pb::Transaction& transaction() const;
  PROTOBUF_NODISCARD ::pb::Transaction* release_transaction();
  ::pb::Transaction* mutable_transaction();
  void set_allocated_transaction(::pb::Transaction* transaction);
  private:
  const ::pb::Transaction& _internal_transaction() const;
  ::pb::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::pb::Transaction* transaction);
  ::pb::Transaction* unsafe_arena_release_transaction();

  // @@protoc_insertion_point(class_scope:pb.RequestSignatureChainTransactionReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::pb::Transaction* transaction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class PinSignatureChain final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PinSignatureChain) */ {
 public:
  inline PinSignatureChain() : PinSignatureChain(nullptr) {}
  ~PinSignatureChain() override;
  explicit PROTOBUF_CONSTEXPR PinSignatureChain(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PinSignatureChain(const PinSignatureChain& from);
  PinSignatureChain(PinSignatureChain&& from) noexcept
    : PinSignatureChain() {
    *this = ::std::move(from);
  }

  inline PinSignatureChain& operator=(const PinSignatureChain& from) {
    CopyFrom(from);
    return *this;
  }
  inline PinSignatureChain& operator=(PinSignatureChain&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PinSignatureChain& default_instance() {
    return *internal_default_instance();
  }
  static inline const PinSignatureChain* internal_default_instance() {
    return reinterpret_cast<const PinSignatureChain*>(
               &_PinSignatureChain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PinSignatureChain& a, PinSignatureChain& b) {
    a.Swap(&b);
  }
  inline void Swap(PinSignatureChain* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PinSignatureChain* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PinSignatureChain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PinSignatureChain>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PinSignatureChain& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PinSignatureChain& from) {
    PinSignatureChain::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PinSignatureChain* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PinSignatureChain";
  }
  protected:
  explicit PinSignatureChain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
  };
  // bytes hash = 1;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // @@protoc_insertion_point(class_scope:pb.PinSignatureChain)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class SignatureChainObjectionUnsigned final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.SignatureChainObjectionUnsigned) */ {
 public:
  inline SignatureChainObjectionUnsigned() : SignatureChainObjectionUnsigned(nullptr) {}
  ~SignatureChainObjectionUnsigned() override;
  explicit PROTOBUF_CONSTEXPR SignatureChainObjectionUnsigned(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignatureChainObjectionUnsigned(const SignatureChainObjectionUnsigned& from);
  SignatureChainObjectionUnsigned(SignatureChainObjectionUnsigned&& from) noexcept
    : SignatureChainObjectionUnsigned() {
    *this = ::std::move(from);
  }

  inline SignatureChainObjectionUnsigned& operator=(const SignatureChainObjectionUnsigned& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignatureChainObjectionUnsigned& operator=(SignatureChainObjectionUnsigned&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignatureChainObjectionUnsigned& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignatureChainObjectionUnsigned* internal_default_instance() {
    return reinterpret_cast<const SignatureChainObjectionUnsigned*>(
               &_SignatureChainObjectionUnsigned_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SignatureChainObjectionUnsigned& a, SignatureChainObjectionUnsigned& b) {
    a.Swap(&b);
  }
  inline void Swap(SignatureChainObjectionUnsigned* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignatureChainObjectionUnsigned* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignatureChainObjectionUnsigned* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignatureChainObjectionUnsigned>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignatureChainObjectionUnsigned& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignatureChainObjectionUnsigned& from) {
    SignatureChainObjectionUnsigned::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignatureChainObjectionUnsigned* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.SignatureChainObjectionUnsigned";
  }
  protected:
  explicit SignatureChainObjectionUnsigned(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureHashFieldNumber = 2,
    kReporterPubkeyFieldNumber = 3,
    kHeightFieldNumber = 1,
  };
  // bytes signature_hash = 2;
  void clear_signature_hash();
  const std::string& signature_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature_hash();
  PROTOBUF_NODISCARD std::string* release_signature_hash();
  void set_allocated_signature_hash(std::string* signature_hash);
  private:
  const std::string& _internal_signature_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature_hash(const std::string& value);
  std::string* _internal_mutable_signature_hash();
  public:

  // bytes reporter_pubkey = 3;
  void clear_reporter_pubkey();
  const std::string& reporter_pubkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reporter_pubkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reporter_pubkey();
  PROTOBUF_NODISCARD std::string* release_reporter_pubkey();
  void set_allocated_reporter_pubkey(std::string* reporter_pubkey);
  private:
  const std::string& _internal_reporter_pubkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reporter_pubkey(const std::string& value);
  std::string* _internal_mutable_reporter_pubkey();
  public:

  // uint32 height = 1;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pb.SignatureChainObjectionUnsigned)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reporter_pubkey_;
    uint32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// -------------------------------------------------------------------

class SignatureChainObjectionSigned final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.SignatureChainObjectionSigned) */ {
 public:
  inline SignatureChainObjectionSigned() : SignatureChainObjectionSigned(nullptr) {}
  ~SignatureChainObjectionSigned() override;
  explicit PROTOBUF_CONSTEXPR SignatureChainObjectionSigned(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignatureChainObjectionSigned(const SignatureChainObjectionSigned& from);
  SignatureChainObjectionSigned(SignatureChainObjectionSigned&& from) noexcept
    : SignatureChainObjectionSigned() {
    *this = ::std::move(from);
  }

  inline SignatureChainObjectionSigned& operator=(const SignatureChainObjectionSigned& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignatureChainObjectionSigned& operator=(SignatureChainObjectionSigned&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignatureChainObjectionSigned& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignatureChainObjectionSigned* internal_default_instance() {
    return reinterpret_cast<const SignatureChainObjectionSigned*>(
               &_SignatureChainObjectionSigned_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SignatureChainObjectionSigned& a, SignatureChainObjectionSigned& b) {
    a.Swap(&b);
  }
  inline void Swap(SignatureChainObjectionSigned* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignatureChainObjectionSigned* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignatureChainObjectionSigned* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignatureChainObjectionSigned>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignatureChainObjectionSigned& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignatureChainObjectionSigned& from) {
    SignatureChainObjectionSigned::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignatureChainObjectionSigned* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.SignatureChainObjectionSigned";
  }
  protected:
  explicit SignatureChainObjectionSigned(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kSignatureFieldNumber = 2,
  };
  // bytes message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bytes signature = 2;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // @@protoc_insertion_point(class_scope:pb.SignatureChainObjectionSigned)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pb_2fnodemessage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UnsignedMessage

// .pb.MessageType message_type = 1;
inline void UnsignedMessage::clear_message_type() {
  _impl_.message_type_ = 0;
}
inline ::pb::MessageType UnsignedMessage::_internal_message_type() const {
  return static_cast< ::pb::MessageType >(_impl_.message_type_);
}
inline ::pb::MessageType UnsignedMessage::message_type() const {
  // @@protoc_insertion_point(field_get:pb.UnsignedMessage.message_type)
  return _internal_message_type();
}
inline void UnsignedMessage::_internal_set_message_type(::pb::MessageType value) {
  
  _impl_.message_type_ = value;
}
inline void UnsignedMessage::set_message_type(::pb::MessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:pb.UnsignedMessage.message_type)
}

// bytes message = 2;
inline void UnsignedMessage::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UnsignedMessage::message() const {
  // @@protoc_insertion_point(field_get:pb.UnsignedMessage.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnsignedMessage::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.UnsignedMessage.message)
}
inline std::string* UnsignedMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pb.UnsignedMessage.message)
  return _s;
}
inline const std::string& UnsignedMessage::_internal_message() const {
  return _impl_.message_.Get();
}
inline void UnsignedMessage::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* UnsignedMessage::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* UnsignedMessage::release_message() {
  // @@protoc_insertion_point(field_release:pb.UnsignedMessage.message)
  return _impl_.message_.Release();
}
inline void UnsignedMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.UnsignedMessage.message)
}

// -------------------------------------------------------------------

// SignedMessage

// bytes message = 1;
inline void SignedMessage::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& SignedMessage::message() const {
  // @@protoc_insertion_point(field_get:pb.SignedMessage.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignedMessage::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.SignedMessage.message)
}
inline std::string* SignedMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pb.SignedMessage.message)
  return _s;
}
inline const std::string& SignedMessage::_internal_message() const {
  return _impl_.message_.Get();
}
inline void SignedMessage::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* SignedMessage::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* SignedMessage::release_message() {
  // @@protoc_insertion_point(field_release:pb.SignedMessage.message)
  return _impl_.message_.Release();
}
inline void SignedMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.SignedMessage.message)
}

// bytes signature = 2;
inline void SignedMessage::clear_signature() {
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& SignedMessage::signature() const {
  // @@protoc_insertion_point(field_get:pb.SignedMessage.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignedMessage::set_signature(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.SignedMessage.signature)
}
inline std::string* SignedMessage::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:pb.SignedMessage.signature)
  return _s;
}
inline const std::string& SignedMessage::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void SignedMessage::_internal_set_signature(const std::string& value) {
  
  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* SignedMessage::_internal_mutable_signature() {
  
  return _impl_.signature_.Mutable(GetArenaForAllocation());
}
inline std::string* SignedMessage::release_signature() {
  // @@protoc_insertion_point(field_release:pb.SignedMessage.signature)
  return _impl_.signature_.Release();
}
inline void SignedMessage::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  _impl_.signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.SignedMessage.signature)
}

// -------------------------------------------------------------------

// Vote

// uint32 height = 1;
inline void Vote::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t Vote::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t Vote::height() const {
  // @@protoc_insertion_point(field_get:pb.Vote.height)
  return _internal_height();
}
inline void Vote::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void Vote::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:pb.Vote.height)
}

// bytes block_hash = 2;
inline void Vote::clear_block_hash() {
  _impl_.block_hash_.ClearToEmpty();
}
inline const std::string& Vote::block_hash() const {
  // @@protoc_insertion_point(field_get:pb.Vote.block_hash)
  return _internal_block_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Vote::set_block_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Vote.block_hash)
}
inline std::string* Vote::mutable_block_hash() {
  std::string* _s = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:pb.Vote.block_hash)
  return _s;
}
inline const std::string& Vote::_internal_block_hash() const {
  return _impl_.block_hash_.Get();
}
inline void Vote::_internal_set_block_hash(const std::string& value) {
  
  _impl_.block_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Vote::_internal_mutable_block_hash() {
  
  return _impl_.block_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Vote::release_block_hash() {
  // @@protoc_insertion_point(field_release:pb.Vote.block_hash)
  return _impl_.block_hash_.Release();
}
inline void Vote::set_allocated_block_hash(std::string* block_hash) {
  if (block_hash != nullptr) {
    
  } else {
    
  }
  _impl_.block_hash_.SetAllocated(block_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_hash_.IsDefault()) {
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.Vote.block_hash)
}

// -------------------------------------------------------------------

// IHaveBlockProposal

// uint32 height = 1;
inline void IHaveBlockProposal::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t IHaveBlockProposal::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t IHaveBlockProposal::height() const {
  // @@protoc_insertion_point(field_get:pb.IHaveBlockProposal.height)
  return _internal_height();
}
inline void IHaveBlockProposal::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void IHaveBlockProposal::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:pb.IHaveBlockProposal.height)
}

// bytes block_hash = 2;
inline void IHaveBlockProposal::clear_block_hash() {
  _impl_.block_hash_.ClearToEmpty();
}
inline const std::string& IHaveBlockProposal::block_hash() const {
  // @@protoc_insertion_point(field_get:pb.IHaveBlockProposal.block_hash)
  return _internal_block_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IHaveBlockProposal::set_block_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.IHaveBlockProposal.block_hash)
}
inline std::string* IHaveBlockProposal::mutable_block_hash() {
  std::string* _s = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:pb.IHaveBlockProposal.block_hash)
  return _s;
}
inline const std::string& IHaveBlockProposal::_internal_block_hash() const {
  return _impl_.block_hash_.Get();
}
inline void IHaveBlockProposal::_internal_set_block_hash(const std::string& value) {
  
  _impl_.block_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* IHaveBlockProposal::_internal_mutable_block_hash() {
  
  return _impl_.block_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* IHaveBlockProposal::release_block_hash() {
  // @@protoc_insertion_point(field_release:pb.IHaveBlockProposal.block_hash)
  return _impl_.block_hash_.Release();
}
inline void IHaveBlockProposal::set_allocated_block_hash(std::string* block_hash) {
  if (block_hash != nullptr) {
    
  } else {
    
  }
  _impl_.block_hash_.SetAllocated(block_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_hash_.IsDefault()) {
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.IHaveBlockProposal.block_hash)
}

// -------------------------------------------------------------------

// RequestBlockProposal

// bytes block_hash = 1;
inline void RequestBlockProposal::clear_block_hash() {
  _impl_.block_hash_.ClearToEmpty();
}
inline const std::string& RequestBlockProposal::block_hash() const {
  // @@protoc_insertion_point(field_get:pb.RequestBlockProposal.block_hash)
  return _internal_block_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestBlockProposal::set_block_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.RequestBlockProposal.block_hash)
}
inline std::string* RequestBlockProposal::mutable_block_hash() {
  std::string* _s = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:pb.RequestBlockProposal.block_hash)
  return _s;
}
inline const std::string& RequestBlockProposal::_internal_block_hash() const {
  return _impl_.block_hash_.Get();
}
inline void RequestBlockProposal::_internal_set_block_hash(const std::string& value) {
  
  _impl_.block_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestBlockProposal::_internal_mutable_block_hash() {
  
  return _impl_.block_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestBlockProposal::release_block_hash() {
  // @@protoc_insertion_point(field_release:pb.RequestBlockProposal.block_hash)
  return _impl_.block_hash_.Release();
}
inline void RequestBlockProposal::set_allocated_block_hash(std::string* block_hash) {
  if (block_hash != nullptr) {
    
  } else {
    
  }
  _impl_.block_hash_.SetAllocated(block_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_hash_.IsDefault()) {
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.RequestBlockProposal.block_hash)
}

// .pb.RequestTransactionType type = 2;
inline void RequestBlockProposal::clear_type() {
  _impl_.type_ = 0;
}
inline ::pb::RequestTransactionType RequestBlockProposal::_internal_type() const {
  return static_cast< ::pb::RequestTransactionType >(_impl_.type_);
}
inline ::pb::RequestTransactionType RequestBlockProposal::type() const {
  // @@protoc_insertion_point(field_get:pb.RequestBlockProposal.type)
  return _internal_type();
}
inline void RequestBlockProposal::_internal_set_type(::pb::RequestTransactionType value) {
  
  _impl_.type_ = value;
}
inline void RequestBlockProposal::set_type(::pb::RequestTransactionType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.RequestBlockProposal.type)
}

// bytes short_hash_salt = 3;
inline void RequestBlockProposal::clear_short_hash_salt() {
  _impl_.short_hash_salt_.ClearToEmpty();
}
inline const std::string& RequestBlockProposal::short_hash_salt() const {
  // @@protoc_insertion_point(field_get:pb.RequestBlockProposal.short_hash_salt)
  return _internal_short_hash_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestBlockProposal::set_short_hash_salt(ArgT0&& arg0, ArgT... args) {
 
 _impl_.short_hash_salt_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.RequestBlockProposal.short_hash_salt)
}
inline std::string* RequestBlockProposal::mutable_short_hash_salt() {
  std::string* _s = _internal_mutable_short_hash_salt();
  // @@protoc_insertion_point(field_mutable:pb.RequestBlockProposal.short_hash_salt)
  return _s;
}
inline const std::string& RequestBlockProposal::_internal_short_hash_salt() const {
  return _impl_.short_hash_salt_.Get();
}
inline void RequestBlockProposal::_internal_set_short_hash_salt(const std::string& value) {
  
  _impl_.short_hash_salt_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestBlockProposal::_internal_mutable_short_hash_salt() {
  
  return _impl_.short_hash_salt_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestBlockProposal::release_short_hash_salt() {
  // @@protoc_insertion_point(field_release:pb.RequestBlockProposal.short_hash_salt)
  return _impl_.short_hash_salt_.Release();
}
inline void RequestBlockProposal::set_allocated_short_hash_salt(std::string* short_hash_salt) {
  if (short_hash_salt != nullptr) {
    
  } else {
    
  }
  _impl_.short_hash_salt_.SetAllocated(short_hash_salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.short_hash_salt_.IsDefault()) {
    _impl_.short_hash_salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.RequestBlockProposal.short_hash_salt)
}

// uint32 short_hash_size = 4;
inline void RequestBlockProposal::clear_short_hash_size() {
  _impl_.short_hash_size_ = 0u;
}
inline uint32_t RequestBlockProposal::_internal_short_hash_size() const {
  return _impl_.short_hash_size_;
}
inline uint32_t RequestBlockProposal::short_hash_size() const {
  // @@protoc_insertion_point(field_get:pb.RequestBlockProposal.short_hash_size)
  return _internal_short_hash_size();
}
inline void RequestBlockProposal::_internal_set_short_hash_size(uint32_t value) {
  
  _impl_.short_hash_size_ = value;
}
inline void RequestBlockProposal::set_short_hash_size(uint32_t value) {
  _internal_set_short_hash_size(value);
  // @@protoc_insertion_point(field_set:pb.RequestBlockProposal.short_hash_size)
}

// -------------------------------------------------------------------

// RequestBlockProposalReply

// .pb.Block block = 1;
inline bool RequestBlockProposalReply::_internal_has_block() const {
  return this != internal_default_instance() && _impl_.block_ != nullptr;
}
inline bool RequestBlockProposalReply::has_block() const {
  return _internal_has_block();
}
inline const ::pb::Block& RequestBlockProposalReply::_internal_block() const {
  const ::pb::Block* p = _impl_.block_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::Block&>(
      ::pb::_Block_default_instance_);
}
inline const ::pb::Block& RequestBlockProposalReply::block() const {
  // @@protoc_insertion_point(field_get:pb.RequestBlockProposalReply.block)
  return _internal_block();
}
inline void RequestBlockProposalReply::unsafe_arena_set_allocated_block(
    ::pb::Block* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  _impl_.block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.RequestBlockProposalReply.block)
}
inline ::pb::Block* RequestBlockProposalReply::release_block() {
  
  ::pb::Block* temp = _impl_.block_;
  _impl_.block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::Block* RequestBlockProposalReply::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:pb.RequestBlockProposalReply.block)
  
  ::pb::Block* temp = _impl_.block_;
  _impl_.block_ = nullptr;
  return temp;
}
inline ::pb::Block* RequestBlockProposalReply::_internal_mutable_block() {
  
  if (_impl_.block_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::Block>(GetArenaForAllocation());
    _impl_.block_ = p;
  }
  return _impl_.block_;
}
inline ::pb::Block* RequestBlockProposalReply::mutable_block() {
  ::pb::Block* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:pb.RequestBlockProposalReply.block)
  return _msg;
}
inline void RequestBlockProposalReply::set_allocated_block(::pb::Block* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block));
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.block_ = block;
  // @@protoc_insertion_point(field_set_allocated:pb.RequestBlockProposalReply.block)
}

// repeated bytes transactions_hash = 2;
inline int RequestBlockProposalReply::_internal_transactions_hash_size() const {
  return _impl_.transactions_hash_.size();
}
inline int RequestBlockProposalReply::transactions_hash_size() const {
  return _internal_transactions_hash_size();
}
inline void RequestBlockProposalReply::clear_transactions_hash() {
  _impl_.transactions_hash_.Clear();
}
inline std::string* RequestBlockProposalReply::add_transactions_hash() {
  std::string* _s = _internal_add_transactions_hash();
  // @@protoc_insertion_point(field_add_mutable:pb.RequestBlockProposalReply.transactions_hash)
  return _s;
}
inline const std::string& RequestBlockProposalReply::_internal_transactions_hash(int index) const {
  return _impl_.transactions_hash_.Get(index);
}
inline const std::string& RequestBlockProposalReply::transactions_hash(int index) const {
  // @@protoc_insertion_point(field_get:pb.RequestBlockProposalReply.transactions_hash)
  return _internal_transactions_hash(index);
}
inline std::string* RequestBlockProposalReply::mutable_transactions_hash(int index) {
  // @@protoc_insertion_point(field_mutable:pb.RequestBlockProposalReply.transactions_hash)
  return _impl_.transactions_hash_.Mutable(index);
}
inline void RequestBlockProposalReply::set_transactions_hash(int index, const std::string& value) {
  _impl_.transactions_hash_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pb.RequestBlockProposalReply.transactions_hash)
}
inline void RequestBlockProposalReply::set_transactions_hash(int index, std::string&& value) {
  _impl_.transactions_hash_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pb.RequestBlockProposalReply.transactions_hash)
}
inline void RequestBlockProposalReply::set_transactions_hash(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.transactions_hash_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.RequestBlockProposalReply.transactions_hash)
}
inline void RequestBlockProposalReply::set_transactions_hash(int index, const void* value, size_t size) {
  _impl_.transactions_hash_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.RequestBlockProposalReply.transactions_hash)
}
inline std::string* RequestBlockProposalReply::_internal_add_transactions_hash() {
  return _impl_.transactions_hash_.Add();
}
inline void RequestBlockProposalReply::add_transactions_hash(const std::string& value) {
  _impl_.transactions_hash_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.RequestBlockProposalReply.transactions_hash)
}
inline void RequestBlockProposalReply::add_transactions_hash(std::string&& value) {
  _impl_.transactions_hash_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.RequestBlockProposalReply.transactions_hash)
}
inline void RequestBlockProposalReply::add_transactions_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.transactions_hash_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.RequestBlockProposalReply.transactions_hash)
}
inline void RequestBlockProposalReply::add_transactions_hash(const void* value, size_t size) {
  _impl_.transactions_hash_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.RequestBlockProposalReply.transactions_hash)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RequestBlockProposalReply::transactions_hash() const {
  // @@protoc_insertion_point(field_list:pb.RequestBlockProposalReply.transactions_hash)
  return _impl_.transactions_hash_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RequestBlockProposalReply::mutable_transactions_hash() {
  // @@protoc_insertion_point(field_mutable_list:pb.RequestBlockProposalReply.transactions_hash)
  return &_impl_.transactions_hash_;
}

// -------------------------------------------------------------------

// RequestProposalTransactions

// bytes block_hash = 1;
inline void RequestProposalTransactions::clear_block_hash() {
  _impl_.block_hash_.ClearToEmpty();
}
inline const std::string& RequestProposalTransactions::block_hash() const {
  // @@protoc_insertion_point(field_get:pb.RequestProposalTransactions.block_hash)
  return _internal_block_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestProposalTransactions::set_block_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.RequestProposalTransactions.block_hash)
}
inline std::string* RequestProposalTransactions::mutable_block_hash() {
  std::string* _s = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:pb.RequestProposalTransactions.block_hash)
  return _s;
}
inline const std::string& RequestProposalTransactions::_internal_block_hash() const {
  return _impl_.block_hash_.Get();
}
inline void RequestProposalTransactions::_internal_set_block_hash(const std::string& value) {
  
  _impl_.block_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestProposalTransactions::_internal_mutable_block_hash() {
  
  return _impl_.block_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestProposalTransactions::release_block_hash() {
  // @@protoc_insertion_point(field_release:pb.RequestProposalTransactions.block_hash)
  return _impl_.block_hash_.Release();
}
inline void RequestProposalTransactions::set_allocated_block_hash(std::string* block_hash) {
  if (block_hash != nullptr) {
    
  } else {
    
  }
  _impl_.block_hash_.SetAllocated(block_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_hash_.IsDefault()) {
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.RequestProposalTransactions.block_hash)
}

// .pb.RequestTransactionType type = 2;
inline void RequestProposalTransactions::clear_type() {
  _impl_.type_ = 0;
}
inline ::pb::RequestTransactionType RequestProposalTransactions::_internal_type() const {
  return static_cast< ::pb::RequestTransactionType >(_impl_.type_);
}
inline ::pb::RequestTransactionType RequestProposalTransactions::type() const {
  // @@protoc_insertion_point(field_get:pb.RequestProposalTransactions.type)
  return _internal_type();
}
inline void RequestProposalTransactions::_internal_set_type(::pb::RequestTransactionType value) {
  
  _impl_.type_ = value;
}
inline void RequestProposalTransactions::set_type(::pb::RequestTransactionType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.RequestProposalTransactions.type)
}

// bytes short_hash_salt = 3;
inline void RequestProposalTransactions::clear_short_hash_salt() {
  _impl_.short_hash_salt_.ClearToEmpty();
}
inline const std::string& RequestProposalTransactions::short_hash_salt() const {
  // @@protoc_insertion_point(field_get:pb.RequestProposalTransactions.short_hash_salt)
  return _internal_short_hash_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestProposalTransactions::set_short_hash_salt(ArgT0&& arg0, ArgT... args) {
 
 _impl_.short_hash_salt_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.RequestProposalTransactions.short_hash_salt)
}
inline std::string* RequestProposalTransactions::mutable_short_hash_salt() {
  std::string* _s = _internal_mutable_short_hash_salt();
  // @@protoc_insertion_point(field_mutable:pb.RequestProposalTransactions.short_hash_salt)
  return _s;
}
inline const std::string& RequestProposalTransactions::_internal_short_hash_salt() const {
  return _impl_.short_hash_salt_.Get();
}
inline void RequestProposalTransactions::_internal_set_short_hash_salt(const std::string& value) {
  
  _impl_.short_hash_salt_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestProposalTransactions::_internal_mutable_short_hash_salt() {
  
  return _impl_.short_hash_salt_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestProposalTransactions::release_short_hash_salt() {
  // @@protoc_insertion_point(field_release:pb.RequestProposalTransactions.short_hash_salt)
  return _impl_.short_hash_salt_.Release();
}
inline void RequestProposalTransactions::set_allocated_short_hash_salt(std::string* short_hash_salt) {
  if (short_hash_salt != nullptr) {
    
  } else {
    
  }
  _impl_.short_hash_salt_.SetAllocated(short_hash_salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.short_hash_salt_.IsDefault()) {
    _impl_.short_hash_salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.RequestProposalTransactions.short_hash_salt)
}

// uint32 short_hash_size = 4;
inline void RequestProposalTransactions::clear_short_hash_size() {
  _impl_.short_hash_size_ = 0u;
}
inline uint32_t RequestProposalTransactions::_internal_short_hash_size() const {
  return _impl_.short_hash_size_;
}
inline uint32_t RequestProposalTransactions::short_hash_size() const {
  // @@protoc_insertion_point(field_get:pb.RequestProposalTransactions.short_hash_size)
  return _internal_short_hash_size();
}
inline void RequestProposalTransactions::_internal_set_short_hash_size(uint32_t value) {
  
  _impl_.short_hash_size_ = value;
}
inline void RequestProposalTransactions::set_short_hash_size(uint32_t value) {
  _internal_set_short_hash_size(value);
  // @@protoc_insertion_point(field_set:pb.RequestProposalTransactions.short_hash_size)
}

// repeated bytes transactions_hash = 5;
inline int RequestProposalTransactions::_internal_transactions_hash_size() const {
  return _impl_.transactions_hash_.size();
}
inline int RequestProposalTransactions::transactions_hash_size() const {
  return _internal_transactions_hash_size();
}
inline void RequestProposalTransactions::clear_transactions_hash() {
  _impl_.transactions_hash_.Clear();
}
inline std::string* RequestProposalTransactions::add_transactions_hash() {
  std::string* _s = _internal_add_transactions_hash();
  // @@protoc_insertion_point(field_add_mutable:pb.RequestProposalTransactions.transactions_hash)
  return _s;
}
inline const std::string& RequestProposalTransactions::_internal_transactions_hash(int index) const {
  return _impl_.transactions_hash_.Get(index);
}
inline const std::string& RequestProposalTransactions::transactions_hash(int index) const {
  // @@protoc_insertion_point(field_get:pb.RequestProposalTransactions.transactions_hash)
  return _internal_transactions_hash(index);
}
inline std::string* RequestProposalTransactions::mutable_transactions_hash(int index) {
  // @@protoc_insertion_point(field_mutable:pb.RequestProposalTransactions.transactions_hash)
  return _impl_.transactions_hash_.Mutable(index);
}
inline void RequestProposalTransactions::set_transactions_hash(int index, const std::string& value) {
  _impl_.transactions_hash_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pb.RequestProposalTransactions.transactions_hash)
}
inline void RequestProposalTransactions::set_transactions_hash(int index, std::string&& value) {
  _impl_.transactions_hash_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pb.RequestProposalTransactions.transactions_hash)
}
inline void RequestProposalTransactions::set_transactions_hash(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.transactions_hash_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.RequestProposalTransactions.transactions_hash)
}
inline void RequestProposalTransactions::set_transactions_hash(int index, const void* value, size_t size) {
  _impl_.transactions_hash_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.RequestProposalTransactions.transactions_hash)
}
inline std::string* RequestProposalTransactions::_internal_add_transactions_hash() {
  return _impl_.transactions_hash_.Add();
}
inline void RequestProposalTransactions::add_transactions_hash(const std::string& value) {
  _impl_.transactions_hash_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.RequestProposalTransactions.transactions_hash)
}
inline void RequestProposalTransactions::add_transactions_hash(std::string&& value) {
  _impl_.transactions_hash_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.RequestProposalTransactions.transactions_hash)
}
inline void RequestProposalTransactions::add_transactions_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.transactions_hash_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.RequestProposalTransactions.transactions_hash)
}
inline void RequestProposalTransactions::add_transactions_hash(const void* value, size_t size) {
  _impl_.transactions_hash_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.RequestProposalTransactions.transactions_hash)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RequestProposalTransactions::transactions_hash() const {
  // @@protoc_insertion_point(field_list:pb.RequestProposalTransactions.transactions_hash)
  return _impl_.transactions_hash_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RequestProposalTransactions::mutable_transactions_hash() {
  // @@protoc_insertion_point(field_mutable_list:pb.RequestProposalTransactions.transactions_hash)
  return &_impl_.transactions_hash_;
}

// -------------------------------------------------------------------

// RequestProposalTransactionsReply

// repeated .pb.Transaction transactions = 1;
inline int RequestProposalTransactionsReply::_internal_transactions_size() const {
  return _impl_.transactions_.size();
}
inline int RequestProposalTransactionsReply::transactions_size() const {
  return _internal_transactions_size();
}
inline ::pb::Transaction* RequestProposalTransactionsReply::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:pb.RequestProposalTransactionsReply.transactions)
  return _impl_.transactions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Transaction >*
RequestProposalTransactionsReply::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:pb.RequestProposalTransactionsReply.transactions)
  return &_impl_.transactions_;
}
inline const ::pb::Transaction& RequestProposalTransactionsReply::_internal_transactions(int index) const {
  return _impl_.transactions_.Get(index);
}
inline const ::pb::Transaction& RequestProposalTransactionsReply::transactions(int index) const {
  // @@protoc_insertion_point(field_get:pb.RequestProposalTransactionsReply.transactions)
  return _internal_transactions(index);
}
inline ::pb::Transaction* RequestProposalTransactionsReply::_internal_add_transactions() {
  return _impl_.transactions_.Add();
}
inline ::pb::Transaction* RequestProposalTransactionsReply::add_transactions() {
  ::pb::Transaction* _add = _internal_add_transactions();
  // @@protoc_insertion_point(field_add:pb.RequestProposalTransactionsReply.transactions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Transaction >&
RequestProposalTransactionsReply::transactions() const {
  // @@protoc_insertion_point(field_list:pb.RequestProposalTransactionsReply.transactions)
  return _impl_.transactions_;
}

// -------------------------------------------------------------------

// GetConsensusState

// -------------------------------------------------------------------

// GetConsensusStateReply

// bytes ledger_block_hash = 2;
inline void GetConsensusStateReply::clear_ledger_block_hash() {
  _impl_.ledger_block_hash_.ClearToEmpty();
}
inline const std::string& GetConsensusStateReply::ledger_block_hash() const {
  // @@protoc_insertion_point(field_get:pb.GetConsensusStateReply.ledger_block_hash)
  return _internal_ledger_block_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetConsensusStateReply::set_ledger_block_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ledger_block_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.GetConsensusStateReply.ledger_block_hash)
}
inline std::string* GetConsensusStateReply::mutable_ledger_block_hash() {
  std::string* _s = _internal_mutable_ledger_block_hash();
  // @@protoc_insertion_point(field_mutable:pb.GetConsensusStateReply.ledger_block_hash)
  return _s;
}
inline const std::string& GetConsensusStateReply::_internal_ledger_block_hash() const {
  return _impl_.ledger_block_hash_.Get();
}
inline void GetConsensusStateReply::_internal_set_ledger_block_hash(const std::string& value) {
  
  _impl_.ledger_block_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* GetConsensusStateReply::_internal_mutable_ledger_block_hash() {
  
  return _impl_.ledger_block_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* GetConsensusStateReply::release_ledger_block_hash() {
  // @@protoc_insertion_point(field_release:pb.GetConsensusStateReply.ledger_block_hash)
  return _impl_.ledger_block_hash_.Release();
}
inline void GetConsensusStateReply::set_allocated_ledger_block_hash(std::string* ledger_block_hash) {
  if (ledger_block_hash != nullptr) {
    
  } else {
    
  }
  _impl_.ledger_block_hash_.SetAllocated(ledger_block_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ledger_block_hash_.IsDefault()) {
    _impl_.ledger_block_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.GetConsensusStateReply.ledger_block_hash)
}

// uint32 ledger_height = 1;
inline void GetConsensusStateReply::clear_ledger_height() {
  _impl_.ledger_height_ = 0u;
}
inline uint32_t GetConsensusStateReply::_internal_ledger_height() const {
  return _impl_.ledger_height_;
}
inline uint32_t GetConsensusStateReply::ledger_height() const {
  // @@protoc_insertion_point(field_get:pb.GetConsensusStateReply.ledger_height)
  return _internal_ledger_height();
}
inline void GetConsensusStateReply::_internal_set_ledger_height(uint32_t value) {
  
  _impl_.ledger_height_ = value;
}
inline void GetConsensusStateReply::set_ledger_height(uint32_t value) {
  _internal_set_ledger_height(value);
  // @@protoc_insertion_point(field_set:pb.GetConsensusStateReply.ledger_height)
}

// uint32 consensus_height = 3;
inline void GetConsensusStateReply::clear_consensus_height() {
  _impl_.consensus_height_ = 0u;
}
inline uint32_t GetConsensusStateReply::_internal_consensus_height() const {
  return _impl_.consensus_height_;
}
inline uint32_t GetConsensusStateReply::consensus_height() const {
  // @@protoc_insertion_point(field_get:pb.GetConsensusStateReply.consensus_height)
  return _internal_consensus_height();
}
inline void GetConsensusStateReply::_internal_set_consensus_height(uint32_t value) {
  
  _impl_.consensus_height_ = value;
}
inline void GetConsensusStateReply::set_consensus_height(uint32_t value) {
  _internal_set_consensus_height(value);
  // @@protoc_insertion_point(field_set:pb.GetConsensusStateReply.consensus_height)
}

// uint32 min_verifiable_height = 5;
inline void GetConsensusStateReply::clear_min_verifiable_height() {
  _impl_.min_verifiable_height_ = 0u;
}
inline uint32_t GetConsensusStateReply::_internal_min_verifiable_height() const {
  return _impl_.min_verifiable_height_;
}
inline uint32_t GetConsensusStateReply::min_verifiable_height() const {
  // @@protoc_insertion_point(field_get:pb.GetConsensusStateReply.min_verifiable_height)
  return _internal_min_verifiable_height();
}
inline void GetConsensusStateReply::_internal_set_min_verifiable_height(uint32_t value) {
  
  _impl_.min_verifiable_height_ = value;
}
inline void GetConsensusStateReply::set_min_verifiable_height(uint32_t value) {
  _internal_set_min_verifiable_height(value);
  // @@protoc_insertion_point(field_set:pb.GetConsensusStateReply.min_verifiable_height)
}

// .pb.SyncState sync_state = 4;
inline void GetConsensusStateReply::clear_sync_state() {
  _impl_.sync_state_ = 0;
}
inline ::pb::SyncState GetConsensusStateReply::_internal_sync_state() const {
  return static_cast< ::pb::SyncState >(_impl_.sync_state_);
}
inline ::pb::SyncState GetConsensusStateReply::sync_state() const {
  // @@protoc_insertion_point(field_get:pb.GetConsensusStateReply.sync_state)
  return _internal_sync_state();
}
inline void GetConsensusStateReply::_internal_set_sync_state(::pb::SyncState value) {
  
  _impl_.sync_state_ = value;
}
inline void GetConsensusStateReply::set_sync_state(::pb::SyncState value) {
  _internal_set_sync_state(value);
  // @@protoc_insertion_point(field_set:pb.GetConsensusStateReply.sync_state)
}

// -------------------------------------------------------------------

// GetBlockHeaders

// uint32 start_height = 1;
inline void GetBlockHeaders::clear_start_height() {
  _impl_.start_height_ = 0u;
}
inline uint32_t GetBlockHeaders::_internal_start_height() const {
  return _impl_.start_height_;
}
inline uint32_t GetBlockHeaders::start_height() const {
  // @@protoc_insertion_point(field_get:pb.GetBlockHeaders.start_height)
  return _internal_start_height();
}
inline void GetBlockHeaders::_internal_set_start_height(uint32_t value) {
  
  _impl_.start_height_ = value;
}
inline void GetBlockHeaders::set_start_height(uint32_t value) {
  _internal_set_start_height(value);
  // @@protoc_insertion_point(field_set:pb.GetBlockHeaders.start_height)
}

// uint32 end_height = 2;
inline void GetBlockHeaders::clear_end_height() {
  _impl_.end_height_ = 0u;
}
inline uint32_t GetBlockHeaders::_internal_end_height() const {
  return _impl_.end_height_;
}
inline uint32_t GetBlockHeaders::end_height() const {
  // @@protoc_insertion_point(field_get:pb.GetBlockHeaders.end_height)
  return _internal_end_height();
}
inline void GetBlockHeaders::_internal_set_end_height(uint32_t value) {
  
  _impl_.end_height_ = value;
}
inline void GetBlockHeaders::set_end_height(uint32_t value) {
  _internal_set_end_height(value);
  // @@protoc_insertion_point(field_set:pb.GetBlockHeaders.end_height)
}

// -------------------------------------------------------------------

// GetBlockHeadersReply

// repeated .pb.Header block_headers = 1;
inline int GetBlockHeadersReply::_internal_block_headers_size() const {
  return _impl_.block_headers_.size();
}
inline int GetBlockHeadersReply::block_headers_size() const {
  return _internal_block_headers_size();
}
inline ::pb::Header* GetBlockHeadersReply::mutable_block_headers(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GetBlockHeadersReply.block_headers)
  return _impl_.block_headers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Header >*
GetBlockHeadersReply::mutable_block_headers() {
  // @@protoc_insertion_point(field_mutable_list:pb.GetBlockHeadersReply.block_headers)
  return &_impl_.block_headers_;
}
inline const ::pb::Header& GetBlockHeadersReply::_internal_block_headers(int index) const {
  return _impl_.block_headers_.Get(index);
}
inline const ::pb::Header& GetBlockHeadersReply::block_headers(int index) const {
  // @@protoc_insertion_point(field_get:pb.GetBlockHeadersReply.block_headers)
  return _internal_block_headers(index);
}
inline ::pb::Header* GetBlockHeadersReply::_internal_add_block_headers() {
  return _impl_.block_headers_.Add();
}
inline ::pb::Header* GetBlockHeadersReply::add_block_headers() {
  ::pb::Header* _add = _internal_add_block_headers();
  // @@protoc_insertion_point(field_add:pb.GetBlockHeadersReply.block_headers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Header >&
GetBlockHeadersReply::block_headers() const {
  // @@protoc_insertion_point(field_list:pb.GetBlockHeadersReply.block_headers)
  return _impl_.block_headers_;
}

// -------------------------------------------------------------------

// GetBlocks

// uint32 start_height = 1;
inline void GetBlocks::clear_start_height() {
  _impl_.start_height_ = 0u;
}
inline uint32_t GetBlocks::_internal_start_height() const {
  return _impl_.start_height_;
}
inline uint32_t GetBlocks::start_height() const {
  // @@protoc_insertion_point(field_get:pb.GetBlocks.start_height)
  return _internal_start_height();
}
inline void GetBlocks::_internal_set_start_height(uint32_t value) {
  
  _impl_.start_height_ = value;
}
inline void GetBlocks::set_start_height(uint32_t value) {
  _internal_set_start_height(value);
  // @@protoc_insertion_point(field_set:pb.GetBlocks.start_height)
}

// uint32 end_height = 2;
inline void GetBlocks::clear_end_height() {
  _impl_.end_height_ = 0u;
}
inline uint32_t GetBlocks::_internal_end_height() const {
  return _impl_.end_height_;
}
inline uint32_t GetBlocks::end_height() const {
  // @@protoc_insertion_point(field_get:pb.GetBlocks.end_height)
  return _internal_end_height();
}
inline void GetBlocks::_internal_set_end_height(uint32_t value) {
  
  _impl_.end_height_ = value;
}
inline void GetBlocks::set_end_height(uint32_t value) {
  _internal_set_end_height(value);
  // @@protoc_insertion_point(field_set:pb.GetBlocks.end_height)
}

// -------------------------------------------------------------------

// GetBlocksReply

// repeated .pb.Block blocks = 1;
inline int GetBlocksReply::_internal_blocks_size() const {
  return _impl_.blocks_.size();
}
inline int GetBlocksReply::blocks_size() const {
  return _internal_blocks_size();
}
inline ::pb::Block* GetBlocksReply::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GetBlocksReply.blocks)
  return _impl_.blocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Block >*
GetBlocksReply::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:pb.GetBlocksReply.blocks)
  return &_impl_.blocks_;
}
inline const ::pb::Block& GetBlocksReply::_internal_blocks(int index) const {
  return _impl_.blocks_.Get(index);
}
inline const ::pb::Block& GetBlocksReply::blocks(int index) const {
  // @@protoc_insertion_point(field_get:pb.GetBlocksReply.blocks)
  return _internal_blocks(index);
}
inline ::pb::Block* GetBlocksReply::_internal_add_blocks() {
  return _impl_.blocks_.Add();
}
inline ::pb::Block* GetBlocksReply::add_blocks() {
  ::pb::Block* _add = _internal_add_blocks();
  // @@protoc_insertion_point(field_add:pb.GetBlocksReply.blocks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Block >&
GetBlocksReply::blocks() const {
  // @@protoc_insertion_point(field_list:pb.GetBlocksReply.blocks)
  return _impl_.blocks_;
}

// -------------------------------------------------------------------

// StateRequest

// bytes hash = 1;
inline void StateRequest::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& StateRequest::hash() const {
  // @@protoc_insertion_point(field_get:pb.StateRequest.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StateRequest::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.StateRequest.hash)
}
inline std::string* StateRequest::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:pb.StateRequest.hash)
  return _s;
}
inline const std::string& StateRequest::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void StateRequest::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* StateRequest::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* StateRequest::release_hash() {
  // @@protoc_insertion_point(field_release:pb.StateRequest.hash)
  return _impl_.hash_.Release();
}
inline void StateRequest::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.StateRequest.hash)
}

// -------------------------------------------------------------------

// StateNode

// bytes node = 1;
inline void StateNode::clear_node() {
  _impl_.node_.ClearToEmpty();
}
inline const std::string& StateNode::node() const {
  // @@protoc_insertion_point(field_get:pb.StateNode.node)
  return _internal_node();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StateNode::set_node(ArgT0&& arg0, ArgT... args) {
 
 _impl_.node_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.StateNode.node)
}
inline std::string* StateNode::mutable_node() {
  std::string* _s = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:pb.StateNode.node)
  return _s;
}
inline const std::string& StateNode::_internal_node() const {
  return _impl_.node_.Get();
}
inline void StateNode::_internal_set_node(const std::string& value) {
  
  _impl_.node_.Set(value, GetArenaForAllocation());
}
inline std::string* StateNode::_internal_mutable_node() {
  
  return _impl_.node_.Mutable(GetArenaForAllocation());
}
inline std::string* StateNode::release_node() {
  // @@protoc_insertion_point(field_release:pb.StateNode.node)
  return _impl_.node_.Release();
}
inline void StateNode::set_allocated_node(std::string* node) {
  if (node != nullptr) {
    
  } else {
    
  }
  _impl_.node_.SetAllocated(node, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_.IsDefault()) {
    _impl_.node_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.StateNode.node)
}

// -------------------------------------------------------------------

// GetStates

// repeated .pb.StateRequest reqs = 1;
inline int GetStates::_internal_reqs_size() const {
  return _impl_.reqs_.size();
}
inline int GetStates::reqs_size() const {
  return _internal_reqs_size();
}
inline void GetStates::clear_reqs() {
  _impl_.reqs_.Clear();
}
inline ::pb::StateRequest* GetStates::mutable_reqs(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GetStates.reqs)
  return _impl_.reqs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::StateRequest >*
GetStates::mutable_reqs() {
  // @@protoc_insertion_point(field_mutable_list:pb.GetStates.reqs)
  return &_impl_.reqs_;
}
inline const ::pb::StateRequest& GetStates::_internal_reqs(int index) const {
  return _impl_.reqs_.Get(index);
}
inline const ::pb::StateRequest& GetStates::reqs(int index) const {
  // @@protoc_insertion_point(field_get:pb.GetStates.reqs)
  return _internal_reqs(index);
}
inline ::pb::StateRequest* GetStates::_internal_add_reqs() {
  return _impl_.reqs_.Add();
}
inline ::pb::StateRequest* GetStates::add_reqs() {
  ::pb::StateRequest* _add = _internal_add_reqs();
  // @@protoc_insertion_point(field_add:pb.GetStates.reqs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::StateRequest >&
GetStates::reqs() const {
  // @@protoc_insertion_point(field_list:pb.GetStates.reqs)
  return _impl_.reqs_;
}

// -------------------------------------------------------------------

// GetStatesReply

// repeated .pb.StateNode nodes = 1;
inline int GetStatesReply::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int GetStatesReply::nodes_size() const {
  return _internal_nodes_size();
}
inline void GetStatesReply::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::pb::StateNode* GetStatesReply::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GetStatesReply.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::StateNode >*
GetStatesReply::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:pb.GetStatesReply.nodes)
  return &_impl_.nodes_;
}
inline const ::pb::StateNode& GetStatesReply::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::pb::StateNode& GetStatesReply::nodes(int index) const {
  // @@protoc_insertion_point(field_get:pb.GetStatesReply.nodes)
  return _internal_nodes(index);
}
inline ::pb::StateNode* GetStatesReply::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::pb::StateNode* GetStatesReply::add_nodes() {
  ::pb::StateNode* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:pb.GetStatesReply.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::StateNode >&
GetStatesReply::nodes() const {
  // @@protoc_insertion_point(field_list:pb.GetStatesReply.nodes)
  return _impl_.nodes_;
}

// -------------------------------------------------------------------

// Relay

// string src_identifier = 1;
inline void Relay::clear_src_identifier() {
  _impl_.src_identifier_.ClearToEmpty();
}
inline const std::string& Relay::src_identifier() const {
  // @@protoc_insertion_point(field_get:pb.Relay.src_identifier)
  return _internal_src_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Relay::set_src_identifier(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Relay.src_identifier)
}
inline std::string* Relay::mutable_src_identifier() {
  std::string* _s = _internal_mutable_src_identifier();
  // @@protoc_insertion_point(field_mutable:pb.Relay.src_identifier)
  return _s;
}
inline const std::string& Relay::_internal_src_identifier() const {
  return _impl_.src_identifier_.Get();
}
inline void Relay::_internal_set_src_identifier(const std::string& value) {
  
  _impl_.src_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* Relay::_internal_mutable_src_identifier() {
  
  return _impl_.src_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* Relay::release_src_identifier() {
  // @@protoc_insertion_point(field_release:pb.Relay.src_identifier)
  return _impl_.src_identifier_.Release();
}
inline void Relay::set_allocated_src_identifier(std::string* src_identifier) {
  if (src_identifier != nullptr) {
    
  } else {
    
  }
  _impl_.src_identifier_.SetAllocated(src_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_identifier_.IsDefault()) {
    _impl_.src_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.Relay.src_identifier)
}

// bytes src_pubkey = 6;
inline void Relay::clear_src_pubkey() {
  _impl_.src_pubkey_.ClearToEmpty();
}
inline const std::string& Relay::src_pubkey() const {
  // @@protoc_insertion_point(field_get:pb.Relay.src_pubkey)
  return _internal_src_pubkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Relay::set_src_pubkey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_pubkey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Relay.src_pubkey)
}
inline std::string* Relay::mutable_src_pubkey() {
  std::string* _s = _internal_mutable_src_pubkey();
  // @@protoc_insertion_point(field_mutable:pb.Relay.src_pubkey)
  return _s;
}
inline const std::string& Relay::_internal_src_pubkey() const {
  return _impl_.src_pubkey_.Get();
}
inline void Relay::_internal_set_src_pubkey(const std::string& value) {
  
  _impl_.src_pubkey_.Set(value, GetArenaForAllocation());
}
inline std::string* Relay::_internal_mutable_src_pubkey() {
  
  return _impl_.src_pubkey_.Mutable(GetArenaForAllocation());
}
inline std::string* Relay::release_src_pubkey() {
  // @@protoc_insertion_point(field_release:pb.Relay.src_pubkey)
  return _impl_.src_pubkey_.Release();
}
inline void Relay::set_allocated_src_pubkey(std::string* src_pubkey) {
  if (src_pubkey != nullptr) {
    
  } else {
    
  }
  _impl_.src_pubkey_.SetAllocated(src_pubkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_pubkey_.IsDefault()) {
    _impl_.src_pubkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.Relay.src_pubkey)
}

// bytes dest_id = 2;
inline void Relay::clear_dest_id() {
  _impl_.dest_id_.ClearToEmpty();
}
inline const std::string& Relay::dest_id() const {
  // @@protoc_insertion_point(field_get:pb.Relay.dest_id)
  return _internal_dest_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Relay::set_dest_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dest_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Relay.dest_id)
}
inline std::string* Relay::mutable_dest_id() {
  std::string* _s = _internal_mutable_dest_id();
  // @@protoc_insertion_point(field_mutable:pb.Relay.dest_id)
  return _s;
}
inline const std::string& Relay::_internal_dest_id() const {
  return _impl_.dest_id_.Get();
}
inline void Relay::_internal_set_dest_id(const std::string& value) {
  
  _impl_.dest_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Relay::_internal_mutable_dest_id() {
  
  return _impl_.dest_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Relay::release_dest_id() {
  // @@protoc_insertion_point(field_release:pb.Relay.dest_id)
  return _impl_.dest_id_.Release();
}
inline void Relay::set_allocated_dest_id(std::string* dest_id) {
  if (dest_id != nullptr) {
    
  } else {
    
  }
  _impl_.dest_id_.SetAllocated(dest_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dest_id_.IsDefault()) {
    _impl_.dest_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.Relay.dest_id)
}

// bytes payload = 3;
inline void Relay::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& Relay::payload() const {
  // @@protoc_insertion_point(field_get:pb.Relay.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Relay::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Relay.payload)
}
inline std::string* Relay::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:pb.Relay.payload)
  return _s;
}
inline const std::string& Relay::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void Relay::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* Relay::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* Relay::release_payload() {
  // @@protoc_insertion_point(field_release:pb.Relay.payload)
  return _impl_.payload_.Release();
}
inline void Relay::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.Relay.payload)
}

// uint32 max_holding_seconds = 5;
inline void Relay::clear_max_holding_seconds() {
  _impl_.max_holding_seconds_ = 0u;
}
inline uint32_t Relay::_internal_max_holding_seconds() const {
  return _impl_.max_holding_seconds_;
}
inline uint32_t Relay::max_holding_seconds() const {
  // @@protoc_insertion_point(field_get:pb.Relay.max_holding_seconds)
  return _internal_max_holding_seconds();
}
inline void Relay::_internal_set_max_holding_seconds(uint32_t value) {
  
  _impl_.max_holding_seconds_ = value;
}
inline void Relay::set_max_holding_seconds(uint32_t value) {
  _internal_set_max_holding_seconds(value);
  // @@protoc_insertion_point(field_set:pb.Relay.max_holding_seconds)
}

// bytes block_hash = 7;
inline void Relay::clear_block_hash() {
  _impl_.block_hash_.ClearToEmpty();
}
inline const std::string& Relay::block_hash() const {
  // @@protoc_insertion_point(field_get:pb.Relay.block_hash)
  return _internal_block_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Relay::set_block_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Relay.block_hash)
}
inline std::string* Relay::mutable_block_hash() {
  std::string* _s = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:pb.Relay.block_hash)
  return _s;
}
inline const std::string& Relay::_internal_block_hash() const {
  return _impl_.block_hash_.Get();
}
inline void Relay::_internal_set_block_hash(const std::string& value) {
  
  _impl_.block_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Relay::_internal_mutable_block_hash() {
  
  return _impl_.block_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Relay::release_block_hash() {
  // @@protoc_insertion_point(field_release:pb.Relay.block_hash)
  return _impl_.block_hash_.Release();
}
inline void Relay::set_allocated_block_hash(std::string* block_hash) {
  if (block_hash != nullptr) {
    
  } else {
    
  }
  _impl_.block_hash_.SetAllocated(block_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_hash_.IsDefault()) {
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.Relay.block_hash)
}

// bytes last_hash = 8;
inline void Relay::clear_last_hash() {
  _impl_.last_hash_.ClearToEmpty();
}
inline const std::string& Relay::last_hash() const {
  // @@protoc_insertion_point(field_get:pb.Relay.last_hash)
  return _internal_last_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Relay::set_last_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.last_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.Relay.last_hash)
}
inline std::string* Relay::mutable_last_hash() {
  std::string* _s = _internal_mutable_last_hash();
  // @@protoc_insertion_point(field_mutable:pb.Relay.last_hash)
  return _s;
}
inline const std::string& Relay::_internal_last_hash() const {
  return _impl_.last_hash_.Get();
}
inline void Relay::_internal_set_last_hash(const std::string& value) {
  
  _impl_.last_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Relay::_internal_mutable_last_hash() {
  
  return _impl_.last_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Relay::release_last_hash() {
  // @@protoc_insertion_point(field_release:pb.Relay.last_hash)
  return _impl_.last_hash_.Release();
}
inline void Relay::set_allocated_last_hash(std::string* last_hash) {
  if (last_hash != nullptr) {
    
  } else {
    
  }
  _impl_.last_hash_.SetAllocated(last_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.last_hash_.IsDefault()) {
    _impl_.last_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.Relay.last_hash)
}

// uint32 sig_chain_len = 9;
inline void Relay::clear_sig_chain_len() {
  _impl_.sig_chain_len_ = 0u;
}
inline uint32_t Relay::_internal_sig_chain_len() const {
  return _impl_.sig_chain_len_;
}
inline uint32_t Relay::sig_chain_len() const {
  // @@protoc_insertion_point(field_get:pb.Relay.sig_chain_len)
  return _internal_sig_chain_len();
}
inline void Relay::_internal_set_sig_chain_len(uint32_t value) {
  
  _impl_.sig_chain_len_ = value;
}
inline void Relay::set_sig_chain_len(uint32_t value) {
  _internal_set_sig_chain_len(value);
  // @@protoc_insertion_point(field_set:pb.Relay.sig_chain_len)
}

// -------------------------------------------------------------------

// Transactions

// repeated .pb.Transaction transactions = 1;
inline int Transactions::_internal_transactions_size() const {
  return _impl_.transactions_.size();
}
inline int Transactions::transactions_size() const {
  return _internal_transactions_size();
}
inline ::pb::Transaction* Transactions::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Transactions.transactions)
  return _impl_.transactions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Transaction >*
Transactions::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:pb.Transactions.transactions)
  return &_impl_.transactions_;
}
inline const ::pb::Transaction& Transactions::_internal_transactions(int index) const {
  return _impl_.transactions_.Get(index);
}
inline const ::pb::Transaction& Transactions::transactions(int index) const {
  // @@protoc_insertion_point(field_get:pb.Transactions.transactions)
  return _internal_transactions(index);
}
inline ::pb::Transaction* Transactions::_internal_add_transactions() {
  return _impl_.transactions_.Add();
}
inline ::pb::Transaction* Transactions::add_transactions() {
  ::pb::Transaction* _add = _internal_add_transactions();
  // @@protoc_insertion_point(field_add:pb.Transactions.transactions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Transaction >&
Transactions::transactions() const {
  // @@protoc_insertion_point(field_list:pb.Transactions.transactions)
  return _impl_.transactions_;
}

// -------------------------------------------------------------------

// BacktrackSignatureChain

// repeated .pb.SigChainElem sig_chain_elems = 1;
inline int BacktrackSignatureChain::_internal_sig_chain_elems_size() const {
  return _impl_.sig_chain_elems_.size();
}
inline int BacktrackSignatureChain::sig_chain_elems_size() const {
  return _internal_sig_chain_elems_size();
}
inline ::pb::SigChainElem* BacktrackSignatureChain::mutable_sig_chain_elems(int index) {
  // @@protoc_insertion_point(field_mutable:pb.BacktrackSignatureChain.sig_chain_elems)
  return _impl_.sig_chain_elems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::SigChainElem >*
BacktrackSignatureChain::mutable_sig_chain_elems() {
  // @@protoc_insertion_point(field_mutable_list:pb.BacktrackSignatureChain.sig_chain_elems)
  return &_impl_.sig_chain_elems_;
}
inline const ::pb::SigChainElem& BacktrackSignatureChain::_internal_sig_chain_elems(int index) const {
  return _impl_.sig_chain_elems_.Get(index);
}
inline const ::pb::SigChainElem& BacktrackSignatureChain::sig_chain_elems(int index) const {
  // @@protoc_insertion_point(field_get:pb.BacktrackSignatureChain.sig_chain_elems)
  return _internal_sig_chain_elems(index);
}
inline ::pb::SigChainElem* BacktrackSignatureChain::_internal_add_sig_chain_elems() {
  return _impl_.sig_chain_elems_.Add();
}
inline ::pb::SigChainElem* BacktrackSignatureChain::add_sig_chain_elems() {
  ::pb::SigChainElem* _add = _internal_add_sig_chain_elems();
  // @@protoc_insertion_point(field_add:pb.BacktrackSignatureChain.sig_chain_elems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::SigChainElem >&
BacktrackSignatureChain::sig_chain_elems() const {
  // @@protoc_insertion_point(field_list:pb.BacktrackSignatureChain.sig_chain_elems)
  return _impl_.sig_chain_elems_;
}

// bytes hash = 2;
inline void BacktrackSignatureChain::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& BacktrackSignatureChain::hash() const {
  // @@protoc_insertion_point(field_get:pb.BacktrackSignatureChain.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BacktrackSignatureChain::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.BacktrackSignatureChain.hash)
}
inline std::string* BacktrackSignatureChain::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:pb.BacktrackSignatureChain.hash)
  return _s;
}
inline const std::string& BacktrackSignatureChain::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void BacktrackSignatureChain::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* BacktrackSignatureChain::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* BacktrackSignatureChain::release_hash() {
  // @@protoc_insertion_point(field_release:pb.BacktrackSignatureChain.hash)
  return _impl_.hash_.Release();
}
inline void BacktrackSignatureChain::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.BacktrackSignatureChain.hash)
}

// -------------------------------------------------------------------

// IHaveSignatureChainTransaction

// uint32 height = 1;
inline void IHaveSignatureChainTransaction::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t IHaveSignatureChainTransaction::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t IHaveSignatureChainTransaction::height() const {
  // @@protoc_insertion_point(field_get:pb.IHaveSignatureChainTransaction.height)
  return _internal_height();
}
inline void IHaveSignatureChainTransaction::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void IHaveSignatureChainTransaction::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:pb.IHaveSignatureChainTransaction.height)
}

// bytes signature_hash = 2;
inline void IHaveSignatureChainTransaction::clear_signature_hash() {
  _impl_.signature_hash_.ClearToEmpty();
}
inline const std::string& IHaveSignatureChainTransaction::signature_hash() const {
  // @@protoc_insertion_point(field_get:pb.IHaveSignatureChainTransaction.signature_hash)
  return _internal_signature_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IHaveSignatureChainTransaction::set_signature_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signature_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.IHaveSignatureChainTransaction.signature_hash)
}
inline std::string* IHaveSignatureChainTransaction::mutable_signature_hash() {
  std::string* _s = _internal_mutable_signature_hash();
  // @@protoc_insertion_point(field_mutable:pb.IHaveSignatureChainTransaction.signature_hash)
  return _s;
}
inline const std::string& IHaveSignatureChainTransaction::_internal_signature_hash() const {
  return _impl_.signature_hash_.Get();
}
inline void IHaveSignatureChainTransaction::_internal_set_signature_hash(const std::string& value) {
  
  _impl_.signature_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* IHaveSignatureChainTransaction::_internal_mutable_signature_hash() {
  
  return _impl_.signature_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* IHaveSignatureChainTransaction::release_signature_hash() {
  // @@protoc_insertion_point(field_release:pb.IHaveSignatureChainTransaction.signature_hash)
  return _impl_.signature_hash_.Release();
}
inline void IHaveSignatureChainTransaction::set_allocated_signature_hash(std::string* signature_hash) {
  if (signature_hash != nullptr) {
    
  } else {
    
  }
  _impl_.signature_hash_.SetAllocated(signature_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_hash_.IsDefault()) {
    _impl_.signature_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.IHaveSignatureChainTransaction.signature_hash)
}

// -------------------------------------------------------------------

// RequestSignatureChainTransaction

// bytes signature_hash = 1;
inline void RequestSignatureChainTransaction::clear_signature_hash() {
  _impl_.signature_hash_.ClearToEmpty();
}
inline const std::string& RequestSignatureChainTransaction::signature_hash() const {
  // @@protoc_insertion_point(field_get:pb.RequestSignatureChainTransaction.signature_hash)
  return _internal_signature_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestSignatureChainTransaction::set_signature_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signature_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.RequestSignatureChainTransaction.signature_hash)
}
inline std::string* RequestSignatureChainTransaction::mutable_signature_hash() {
  std::string* _s = _internal_mutable_signature_hash();
  // @@protoc_insertion_point(field_mutable:pb.RequestSignatureChainTransaction.signature_hash)
  return _s;
}
inline const std::string& RequestSignatureChainTransaction::_internal_signature_hash() const {
  return _impl_.signature_hash_.Get();
}
inline void RequestSignatureChainTransaction::_internal_set_signature_hash(const std::string& value) {
  
  _impl_.signature_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestSignatureChainTransaction::_internal_mutable_signature_hash() {
  
  return _impl_.signature_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestSignatureChainTransaction::release_signature_hash() {
  // @@protoc_insertion_point(field_release:pb.RequestSignatureChainTransaction.signature_hash)
  return _impl_.signature_hash_.Release();
}
inline void RequestSignatureChainTransaction::set_allocated_signature_hash(std::string* signature_hash) {
  if (signature_hash != nullptr) {
    
  } else {
    
  }
  _impl_.signature_hash_.SetAllocated(signature_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_hash_.IsDefault()) {
    _impl_.signature_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.RequestSignatureChainTransaction.signature_hash)
}

// -------------------------------------------------------------------

// RequestSignatureChainTransactionReply

// .pb.Transaction transaction = 1;
inline bool RequestSignatureChainTransactionReply::_internal_has_transaction() const {
  return this != internal_default_instance() && _impl_.transaction_ != nullptr;
}
inline bool RequestSignatureChainTransactionReply::has_transaction() const {
  return _internal_has_transaction();
}
inline const ::pb::Transaction& RequestSignatureChainTransactionReply::_internal_transaction() const {
  const ::pb::Transaction* p = _impl_.transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::Transaction&>(
      ::pb::_Transaction_default_instance_);
}
inline const ::pb::Transaction& RequestSignatureChainTransactionReply::transaction() const {
  // @@protoc_insertion_point(field_get:pb.RequestSignatureChainTransactionReply.transaction)
  return _internal_transaction();
}
inline void RequestSignatureChainTransactionReply::unsafe_arena_set_allocated_transaction(
    ::pb::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transaction_);
  }
  _impl_.transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.RequestSignatureChainTransactionReply.transaction)
}
inline ::pb::Transaction* RequestSignatureChainTransactionReply::release_transaction() {
  
  ::pb::Transaction* temp = _impl_.transaction_;
  _impl_.transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pb::Transaction* RequestSignatureChainTransactionReply::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:pb.RequestSignatureChainTransactionReply.transaction)
  
  ::pb::Transaction* temp = _impl_.transaction_;
  _impl_.transaction_ = nullptr;
  return temp;
}
inline ::pb::Transaction* RequestSignatureChainTransactionReply::_internal_mutable_transaction() {
  
  if (_impl_.transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::Transaction>(GetArenaForAllocation());
    _impl_.transaction_ = p;
  }
  return _impl_.transaction_;
}
inline ::pb::Transaction* RequestSignatureChainTransactionReply::mutable_transaction() {
  ::pb::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:pb.RequestSignatureChainTransactionReply.transaction)
  return _msg;
}
inline void RequestSignatureChainTransactionReply::set_allocated_transaction(::pb::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transaction_);
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction));
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:pb.RequestSignatureChainTransactionReply.transaction)
}

// -------------------------------------------------------------------

// PinSignatureChain

// bytes hash = 1;
inline void PinSignatureChain::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& PinSignatureChain::hash() const {
  // @@protoc_insertion_point(field_get:pb.PinSignatureChain.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PinSignatureChain::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.PinSignatureChain.hash)
}
inline std::string* PinSignatureChain::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:pb.PinSignatureChain.hash)
  return _s;
}
inline const std::string& PinSignatureChain::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void PinSignatureChain::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* PinSignatureChain::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* PinSignatureChain::release_hash() {
  // @@protoc_insertion_point(field_release:pb.PinSignatureChain.hash)
  return _impl_.hash_.Release();
}
inline void PinSignatureChain::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.PinSignatureChain.hash)
}

// -------------------------------------------------------------------

// SignatureChainObjectionUnsigned

// uint32 height = 1;
inline void SignatureChainObjectionUnsigned::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t SignatureChainObjectionUnsigned::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t SignatureChainObjectionUnsigned::height() const {
  // @@protoc_insertion_point(field_get:pb.SignatureChainObjectionUnsigned.height)
  return _internal_height();
}
inline void SignatureChainObjectionUnsigned::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void SignatureChainObjectionUnsigned::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:pb.SignatureChainObjectionUnsigned.height)
}

// bytes signature_hash = 2;
inline void SignatureChainObjectionUnsigned::clear_signature_hash() {
  _impl_.signature_hash_.ClearToEmpty();
}
inline const std::string& SignatureChainObjectionUnsigned::signature_hash() const {
  // @@protoc_insertion_point(field_get:pb.SignatureChainObjectionUnsigned.signature_hash)
  return _internal_signature_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignatureChainObjectionUnsigned::set_signature_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signature_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.SignatureChainObjectionUnsigned.signature_hash)
}
inline std::string* SignatureChainObjectionUnsigned::mutable_signature_hash() {
  std::string* _s = _internal_mutable_signature_hash();
  // @@protoc_insertion_point(field_mutable:pb.SignatureChainObjectionUnsigned.signature_hash)
  return _s;
}
inline const std::string& SignatureChainObjectionUnsigned::_internal_signature_hash() const {
  return _impl_.signature_hash_.Get();
}
inline void SignatureChainObjectionUnsigned::_internal_set_signature_hash(const std::string& value) {
  
  _impl_.signature_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* SignatureChainObjectionUnsigned::_internal_mutable_signature_hash() {
  
  return _impl_.signature_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* SignatureChainObjectionUnsigned::release_signature_hash() {
  // @@protoc_insertion_point(field_release:pb.SignatureChainObjectionUnsigned.signature_hash)
  return _impl_.signature_hash_.Release();
}
inline void SignatureChainObjectionUnsigned::set_allocated_signature_hash(std::string* signature_hash) {
  if (signature_hash != nullptr) {
    
  } else {
    
  }
  _impl_.signature_hash_.SetAllocated(signature_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_hash_.IsDefault()) {
    _impl_.signature_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.SignatureChainObjectionUnsigned.signature_hash)
}

// bytes reporter_pubkey = 3;
inline void SignatureChainObjectionUnsigned::clear_reporter_pubkey() {
  _impl_.reporter_pubkey_.ClearToEmpty();
}
inline const std::string& SignatureChainObjectionUnsigned::reporter_pubkey() const {
  // @@protoc_insertion_point(field_get:pb.SignatureChainObjectionUnsigned.reporter_pubkey)
  return _internal_reporter_pubkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignatureChainObjectionUnsigned::set_reporter_pubkey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reporter_pubkey_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.SignatureChainObjectionUnsigned.reporter_pubkey)
}
inline std::string* SignatureChainObjectionUnsigned::mutable_reporter_pubkey() {
  std::string* _s = _internal_mutable_reporter_pubkey();
  // @@protoc_insertion_point(field_mutable:pb.SignatureChainObjectionUnsigned.reporter_pubkey)
  return _s;
}
inline const std::string& SignatureChainObjectionUnsigned::_internal_reporter_pubkey() const {
  return _impl_.reporter_pubkey_.Get();
}
inline void SignatureChainObjectionUnsigned::_internal_set_reporter_pubkey(const std::string& value) {
  
  _impl_.reporter_pubkey_.Set(value, GetArenaForAllocation());
}
inline std::string* SignatureChainObjectionUnsigned::_internal_mutable_reporter_pubkey() {
  
  return _impl_.reporter_pubkey_.Mutable(GetArenaForAllocation());
}
inline std::string* SignatureChainObjectionUnsigned::release_reporter_pubkey() {
  // @@protoc_insertion_point(field_release:pb.SignatureChainObjectionUnsigned.reporter_pubkey)
  return _impl_.reporter_pubkey_.Release();
}
inline void SignatureChainObjectionUnsigned::set_allocated_reporter_pubkey(std::string* reporter_pubkey) {
  if (reporter_pubkey != nullptr) {
    
  } else {
    
  }
  _impl_.reporter_pubkey_.SetAllocated(reporter_pubkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reporter_pubkey_.IsDefault()) {
    _impl_.reporter_pubkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.SignatureChainObjectionUnsigned.reporter_pubkey)
}

// -------------------------------------------------------------------

// SignatureChainObjectionSigned

// bytes message = 1;
inline void SignatureChainObjectionSigned::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& SignatureChainObjectionSigned::message() const {
  // @@protoc_insertion_point(field_get:pb.SignatureChainObjectionSigned.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignatureChainObjectionSigned::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.SignatureChainObjectionSigned.message)
}
inline std::string* SignatureChainObjectionSigned::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pb.SignatureChainObjectionSigned.message)
  return _s;
}
inline const std::string& SignatureChainObjectionSigned::_internal_message() const {
  return _impl_.message_.Get();
}
inline void SignatureChainObjectionSigned::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* SignatureChainObjectionSigned::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* SignatureChainObjectionSigned::release_message() {
  // @@protoc_insertion_point(field_release:pb.SignatureChainObjectionSigned.message)
  return _impl_.message_.Release();
}
inline void SignatureChainObjectionSigned::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.SignatureChainObjectionSigned.message)
}

// bytes signature = 2;
inline void SignatureChainObjectionSigned::clear_signature() {
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& SignatureChainObjectionSigned::signature() const {
  // @@protoc_insertion_point(field_get:pb.SignatureChainObjectionSigned.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignatureChainObjectionSigned::set_signature(ArgT0&& arg0, ArgT... args) {
 
 _impl_.signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb.SignatureChainObjectionSigned.signature)
}
inline std::string* SignatureChainObjectionSigned::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:pb.SignatureChainObjectionSigned.signature)
  return _s;
}
inline const std::string& SignatureChainObjectionSigned::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void SignatureChainObjectionSigned::_internal_set_signature(const std::string& value) {
  
  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* SignatureChainObjectionSigned::_internal_mutable_signature() {
  
  return _impl_.signature_.Mutable(GetArenaForAllocation());
}
inline std::string* SignatureChainObjectionSigned::release_signature() {
  // @@protoc_insertion_point(field_release:pb.SignatureChainObjectionSigned.signature)
  return _impl_.signature_.Release();
}
inline void SignatureChainObjectionSigned::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  _impl_.signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb.SignatureChainObjectionSigned.signature)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pb::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::MessageType>() {
  return ::pb::MessageType_descriptor();
}
template <> struct is_proto_enum< ::pb::AllowedSignedMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::AllowedSignedMessageType>() {
  return ::pb::AllowedSignedMessageType_descriptor();
}
template <> struct is_proto_enum< ::pb::AllowedUnsignedMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::AllowedUnsignedMessageType>() {
  return ::pb::AllowedUnsignedMessageType_descriptor();
}
template <> struct is_proto_enum< ::pb::AllowedDirectMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::AllowedDirectMessageType>() {
  return ::pb::AllowedDirectMessageType_descriptor();
}
template <> struct is_proto_enum< ::pb::AllowedRelayMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::AllowedRelayMessageType>() {
  return ::pb::AllowedRelayMessageType_descriptor();
}
template <> struct is_proto_enum< ::pb::AllowedBroadcastPushMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::AllowedBroadcastPushMessageType>() {
  return ::pb::AllowedBroadcastPushMessageType_descriptor();
}
template <> struct is_proto_enum< ::pb::AllowedBroadcastPullMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::AllowedBroadcastPullMessageType>() {
  return ::pb::AllowedBroadcastPullMessageType_descriptor();
}
template <> struct is_proto_enum< ::pb::AllowedBroadcastTreeMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::AllowedBroadcastTreeMessageType>() {
  return ::pb::AllowedBroadcastTreeMessageType_descriptor();
}
template <> struct is_proto_enum< ::pb::RequestTransactionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::RequestTransactionType>() {
  return ::pb::RequestTransactionType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pb_2fnodemessage_2eproto
