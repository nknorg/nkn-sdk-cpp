// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb/nodemessage.proto

#include "pb/nodemessage.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace pb {
PROTOBUF_CONSTEXPR UnsignedMessage::UnsignedMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.message_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UnsignedMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnsignedMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnsignedMessageDefaultTypeInternal() {}
  union {
    UnsignedMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnsignedMessageDefaultTypeInternal _UnsignedMessage_default_instance_;
PROTOBUF_CONSTEXPR SignedMessage::SignedMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SignedMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignedMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignedMessageDefaultTypeInternal() {}
  union {
    SignedMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignedMessageDefaultTypeInternal _SignedMessage_default_instance_;
PROTOBUF_CONSTEXPR Vote::Vote(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.block_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.height_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VoteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VoteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VoteDefaultTypeInternal() {}
  union {
    Vote _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VoteDefaultTypeInternal _Vote_default_instance_;
PROTOBUF_CONSTEXPR IHaveBlockProposal::IHaveBlockProposal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.block_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.height_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IHaveBlockProposalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IHaveBlockProposalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IHaveBlockProposalDefaultTypeInternal() {}
  union {
    IHaveBlockProposal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IHaveBlockProposalDefaultTypeInternal _IHaveBlockProposal_default_instance_;
PROTOBUF_CONSTEXPR RequestBlockProposal::RequestBlockProposal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.block_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.short_hash_salt_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.short_hash_size_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RequestBlockProposalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestBlockProposalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestBlockProposalDefaultTypeInternal() {}
  union {
    RequestBlockProposal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestBlockProposalDefaultTypeInternal _RequestBlockProposal_default_instance_;
PROTOBUF_CONSTEXPR RequestBlockProposalReply::RequestBlockProposalReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transactions_hash_)*/{}
  , /*decltype(_impl_.block_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RequestBlockProposalReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestBlockProposalReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestBlockProposalReplyDefaultTypeInternal() {}
  union {
    RequestBlockProposalReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestBlockProposalReplyDefaultTypeInternal _RequestBlockProposalReply_default_instance_;
PROTOBUF_CONSTEXPR RequestProposalTransactions::RequestProposalTransactions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transactions_hash_)*/{}
  , /*decltype(_impl_.block_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.short_hash_salt_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.short_hash_size_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RequestProposalTransactionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestProposalTransactionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestProposalTransactionsDefaultTypeInternal() {}
  union {
    RequestProposalTransactions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestProposalTransactionsDefaultTypeInternal _RequestProposalTransactions_default_instance_;
PROTOBUF_CONSTEXPR RequestProposalTransactionsReply::RequestProposalTransactionsReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transactions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RequestProposalTransactionsReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestProposalTransactionsReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestProposalTransactionsReplyDefaultTypeInternal() {}
  union {
    RequestProposalTransactionsReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestProposalTransactionsReplyDefaultTypeInternal _RequestProposalTransactionsReply_default_instance_;
PROTOBUF_CONSTEXPR GetConsensusState::GetConsensusState(
    ::_pbi::ConstantInitialized) {}
struct GetConsensusStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetConsensusStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetConsensusStateDefaultTypeInternal() {}
  union {
    GetConsensusState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetConsensusStateDefaultTypeInternal _GetConsensusState_default_instance_;
PROTOBUF_CONSTEXPR GetConsensusStateReply::GetConsensusStateReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ledger_block_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ledger_height_)*/0u
  , /*decltype(_impl_.consensus_height_)*/0u
  , /*decltype(_impl_.sync_state_)*/0
  , /*decltype(_impl_.min_verifiable_height_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetConsensusStateReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetConsensusStateReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetConsensusStateReplyDefaultTypeInternal() {}
  union {
    GetConsensusStateReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetConsensusStateReplyDefaultTypeInternal _GetConsensusStateReply_default_instance_;
PROTOBUF_CONSTEXPR GetBlockHeaders::GetBlockHeaders(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.start_height_)*/0u
  , /*decltype(_impl_.end_height_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetBlockHeadersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetBlockHeadersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetBlockHeadersDefaultTypeInternal() {}
  union {
    GetBlockHeaders _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetBlockHeadersDefaultTypeInternal _GetBlockHeaders_default_instance_;
PROTOBUF_CONSTEXPR GetBlockHeadersReply::GetBlockHeadersReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.block_headers_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetBlockHeadersReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetBlockHeadersReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetBlockHeadersReplyDefaultTypeInternal() {}
  union {
    GetBlockHeadersReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetBlockHeadersReplyDefaultTypeInternal _GetBlockHeadersReply_default_instance_;
PROTOBUF_CONSTEXPR GetBlocks::GetBlocks(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.start_height_)*/0u
  , /*decltype(_impl_.end_height_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetBlocksDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetBlocksDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetBlocksDefaultTypeInternal() {}
  union {
    GetBlocks _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetBlocksDefaultTypeInternal _GetBlocks_default_instance_;
PROTOBUF_CONSTEXPR GetBlocksReply::GetBlocksReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.blocks_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetBlocksReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetBlocksReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetBlocksReplyDefaultTypeInternal() {}
  union {
    GetBlocksReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetBlocksReplyDefaultTypeInternal _GetBlocksReply_default_instance_;
PROTOBUF_CONSTEXPR StateRequest::StateRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StateRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StateRequestDefaultTypeInternal() {}
  union {
    StateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StateRequestDefaultTypeInternal _StateRequest_default_instance_;
PROTOBUF_CONSTEXPR StateNode::StateNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.node_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StateNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StateNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StateNodeDefaultTypeInternal() {}
  union {
    StateNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StateNodeDefaultTypeInternal _StateNode_default_instance_;
PROTOBUF_CONSTEXPR GetStates::GetStates(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.reqs_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetStatesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetStatesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetStatesDefaultTypeInternal() {}
  union {
    GetStates _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetStatesDefaultTypeInternal _GetStates_default_instance_;
PROTOBUF_CONSTEXPR GetStatesReply::GetStatesReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nodes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetStatesReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetStatesReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetStatesReplyDefaultTypeInternal() {}
  union {
    GetStatesReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetStatesReplyDefaultTypeInternal _GetStatesReply_default_instance_;
PROTOBUF_CONSTEXPR Relay::Relay(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.src_identifier_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dest_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.payload_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.src_pubkey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.block_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.last_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.max_holding_seconds_)*/0u
  , /*decltype(_impl_.sig_chain_len_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RelayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RelayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RelayDefaultTypeInternal() {}
  union {
    Relay _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RelayDefaultTypeInternal _Relay_default_instance_;
PROTOBUF_CONSTEXPR Transactions::Transactions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transactions_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TransactionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransactionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransactionsDefaultTypeInternal() {}
  union {
    Transactions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransactionsDefaultTypeInternal _Transactions_default_instance_;
PROTOBUF_CONSTEXPR BacktrackSignatureChain::BacktrackSignatureChain(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sig_chain_elems_)*/{}
  , /*decltype(_impl_.hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BacktrackSignatureChainDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BacktrackSignatureChainDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BacktrackSignatureChainDefaultTypeInternal() {}
  union {
    BacktrackSignatureChain _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BacktrackSignatureChainDefaultTypeInternal _BacktrackSignatureChain_default_instance_;
PROTOBUF_CONSTEXPR IHaveSignatureChainTransaction::IHaveSignatureChainTransaction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.signature_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.height_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IHaveSignatureChainTransactionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IHaveSignatureChainTransactionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IHaveSignatureChainTransactionDefaultTypeInternal() {}
  union {
    IHaveSignatureChainTransaction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IHaveSignatureChainTransactionDefaultTypeInternal _IHaveSignatureChainTransaction_default_instance_;
PROTOBUF_CONSTEXPR RequestSignatureChainTransaction::RequestSignatureChainTransaction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.signature_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RequestSignatureChainTransactionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestSignatureChainTransactionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestSignatureChainTransactionDefaultTypeInternal() {}
  union {
    RequestSignatureChainTransaction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestSignatureChainTransactionDefaultTypeInternal _RequestSignatureChainTransaction_default_instance_;
PROTOBUF_CONSTEXPR RequestSignatureChainTransactionReply::RequestSignatureChainTransactionReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transaction_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RequestSignatureChainTransactionReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestSignatureChainTransactionReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestSignatureChainTransactionReplyDefaultTypeInternal() {}
  union {
    RequestSignatureChainTransactionReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestSignatureChainTransactionReplyDefaultTypeInternal _RequestSignatureChainTransactionReply_default_instance_;
PROTOBUF_CONSTEXPR PinSignatureChain::PinSignatureChain(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PinSignatureChainDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PinSignatureChainDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PinSignatureChainDefaultTypeInternal() {}
  union {
    PinSignatureChain _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PinSignatureChainDefaultTypeInternal _PinSignatureChain_default_instance_;
PROTOBUF_CONSTEXPR SignatureChainObjectionUnsigned::SignatureChainObjectionUnsigned(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.signature_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reporter_pubkey_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.height_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SignatureChainObjectionUnsignedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignatureChainObjectionUnsignedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignatureChainObjectionUnsignedDefaultTypeInternal() {}
  union {
    SignatureChainObjectionUnsigned _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignatureChainObjectionUnsignedDefaultTypeInternal _SignatureChainObjectionUnsigned_default_instance_;
PROTOBUF_CONSTEXPR SignatureChainObjectionSigned::SignatureChainObjectionSigned(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SignatureChainObjectionSignedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignatureChainObjectionSignedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignatureChainObjectionSignedDefaultTypeInternal() {}
  union {
    SignatureChainObjectionSigned _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignatureChainObjectionSignedDefaultTypeInternal _SignatureChainObjectionSigned_default_instance_;
}  // namespace pb
static ::_pb::Metadata file_level_metadata_pb_2fnodemessage_2eproto[27];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_pb_2fnodemessage_2eproto[9];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_pb_2fnodemessage_2eproto = nullptr;

const uint32_t TableStruct_pb_2fnodemessage_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::UnsignedMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::UnsignedMessage, _impl_.message_type_),
  PROTOBUF_FIELD_OFFSET(::pb::UnsignedMessage, _impl_.message_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::SignedMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::SignedMessage, _impl_.message_),
  PROTOBUF_FIELD_OFFSET(::pb::SignedMessage, _impl_.signature_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::Vote, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::Vote, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::pb::Vote, _impl_.block_hash_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::IHaveBlockProposal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::IHaveBlockProposal, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::pb::IHaveBlockProposal, _impl_.block_hash_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::RequestBlockProposal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::RequestBlockProposal, _impl_.block_hash_),
  PROTOBUF_FIELD_OFFSET(::pb::RequestBlockProposal, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::pb::RequestBlockProposal, _impl_.short_hash_salt_),
  PROTOBUF_FIELD_OFFSET(::pb::RequestBlockProposal, _impl_.short_hash_size_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::RequestBlockProposalReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::RequestBlockProposalReply, _impl_.block_),
  PROTOBUF_FIELD_OFFSET(::pb::RequestBlockProposalReply, _impl_.transactions_hash_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::RequestProposalTransactions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::RequestProposalTransactions, _impl_.block_hash_),
  PROTOBUF_FIELD_OFFSET(::pb::RequestProposalTransactions, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::pb::RequestProposalTransactions, _impl_.short_hash_salt_),
  PROTOBUF_FIELD_OFFSET(::pb::RequestProposalTransactions, _impl_.short_hash_size_),
  PROTOBUF_FIELD_OFFSET(::pb::RequestProposalTransactions, _impl_.transactions_hash_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::RequestProposalTransactionsReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::RequestProposalTransactionsReply, _impl_.transactions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::GetConsensusState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::GetConsensusStateReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::GetConsensusStateReply, _impl_.ledger_block_hash_),
  PROTOBUF_FIELD_OFFSET(::pb::GetConsensusStateReply, _impl_.ledger_height_),
  PROTOBUF_FIELD_OFFSET(::pb::GetConsensusStateReply, _impl_.consensus_height_),
  PROTOBUF_FIELD_OFFSET(::pb::GetConsensusStateReply, _impl_.min_verifiable_height_),
  PROTOBUF_FIELD_OFFSET(::pb::GetConsensusStateReply, _impl_.sync_state_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::GetBlockHeaders, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::GetBlockHeaders, _impl_.start_height_),
  PROTOBUF_FIELD_OFFSET(::pb::GetBlockHeaders, _impl_.end_height_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::GetBlockHeadersReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::GetBlockHeadersReply, _impl_.block_headers_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::GetBlocks, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::GetBlocks, _impl_.start_height_),
  PROTOBUF_FIELD_OFFSET(::pb::GetBlocks, _impl_.end_height_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::GetBlocksReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::GetBlocksReply, _impl_.blocks_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::StateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::StateRequest, _impl_.hash_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::StateNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::StateNode, _impl_.node_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::GetStates, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::GetStates, _impl_.reqs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::GetStatesReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::GetStatesReply, _impl_.nodes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::Relay, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::Relay, _impl_.src_identifier_),
  PROTOBUF_FIELD_OFFSET(::pb::Relay, _impl_.src_pubkey_),
  PROTOBUF_FIELD_OFFSET(::pb::Relay, _impl_.dest_id_),
  PROTOBUF_FIELD_OFFSET(::pb::Relay, _impl_.payload_),
  PROTOBUF_FIELD_OFFSET(::pb::Relay, _impl_.max_holding_seconds_),
  PROTOBUF_FIELD_OFFSET(::pb::Relay, _impl_.block_hash_),
  PROTOBUF_FIELD_OFFSET(::pb::Relay, _impl_.last_hash_),
  PROTOBUF_FIELD_OFFSET(::pb::Relay, _impl_.sig_chain_len_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::Transactions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::Transactions, _impl_.transactions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::BacktrackSignatureChain, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::BacktrackSignatureChain, _impl_.sig_chain_elems_),
  PROTOBUF_FIELD_OFFSET(::pb::BacktrackSignatureChain, _impl_.hash_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::IHaveSignatureChainTransaction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::IHaveSignatureChainTransaction, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::pb::IHaveSignatureChainTransaction, _impl_.signature_hash_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::RequestSignatureChainTransaction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::RequestSignatureChainTransaction, _impl_.signature_hash_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::RequestSignatureChainTransactionReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::RequestSignatureChainTransactionReply, _impl_.transaction_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::PinSignatureChain, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::PinSignatureChain, _impl_.hash_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::SignatureChainObjectionUnsigned, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::SignatureChainObjectionUnsigned, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::pb::SignatureChainObjectionUnsigned, _impl_.signature_hash_),
  PROTOBUF_FIELD_OFFSET(::pb::SignatureChainObjectionUnsigned, _impl_.reporter_pubkey_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pb::SignatureChainObjectionSigned, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pb::SignatureChainObjectionSigned, _impl_.message_),
  PROTOBUF_FIELD_OFFSET(::pb::SignatureChainObjectionSigned, _impl_.signature_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::pb::UnsignedMessage)},
  { 8, -1, -1, sizeof(::pb::SignedMessage)},
  { 16, -1, -1, sizeof(::pb::Vote)},
  { 24, -1, -1, sizeof(::pb::IHaveBlockProposal)},
  { 32, -1, -1, sizeof(::pb::RequestBlockProposal)},
  { 42, -1, -1, sizeof(::pb::RequestBlockProposalReply)},
  { 50, -1, -1, sizeof(::pb::RequestProposalTransactions)},
  { 61, -1, -1, sizeof(::pb::RequestProposalTransactionsReply)},
  { 68, -1, -1, sizeof(::pb::GetConsensusState)},
  { 74, -1, -1, sizeof(::pb::GetConsensusStateReply)},
  { 85, -1, -1, sizeof(::pb::GetBlockHeaders)},
  { 93, -1, -1, sizeof(::pb::GetBlockHeadersReply)},
  { 100, -1, -1, sizeof(::pb::GetBlocks)},
  { 108, -1, -1, sizeof(::pb::GetBlocksReply)},
  { 115, -1, -1, sizeof(::pb::StateRequest)},
  { 122, -1, -1, sizeof(::pb::StateNode)},
  { 129, -1, -1, sizeof(::pb::GetStates)},
  { 136, -1, -1, sizeof(::pb::GetStatesReply)},
  { 143, -1, -1, sizeof(::pb::Relay)},
  { 157, -1, -1, sizeof(::pb::Transactions)},
  { 164, -1, -1, sizeof(::pb::BacktrackSignatureChain)},
  { 172, -1, -1, sizeof(::pb::IHaveSignatureChainTransaction)},
  { 180, -1, -1, sizeof(::pb::RequestSignatureChainTransaction)},
  { 187, -1, -1, sizeof(::pb::RequestSignatureChainTransactionReply)},
  { 194, -1, -1, sizeof(::pb::PinSignatureChain)},
  { 201, -1, -1, sizeof(::pb::SignatureChainObjectionUnsigned)},
  { 210, -1, -1, sizeof(::pb::SignatureChainObjectionSigned)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::pb::_UnsignedMessage_default_instance_._instance,
  &::pb::_SignedMessage_default_instance_._instance,
  &::pb::_Vote_default_instance_._instance,
  &::pb::_IHaveBlockProposal_default_instance_._instance,
  &::pb::_RequestBlockProposal_default_instance_._instance,
  &::pb::_RequestBlockProposalReply_default_instance_._instance,
  &::pb::_RequestProposalTransactions_default_instance_._instance,
  &::pb::_RequestProposalTransactionsReply_default_instance_._instance,
  &::pb::_GetConsensusState_default_instance_._instance,
  &::pb::_GetConsensusStateReply_default_instance_._instance,
  &::pb::_GetBlockHeaders_default_instance_._instance,
  &::pb::_GetBlockHeadersReply_default_instance_._instance,
  &::pb::_GetBlocks_default_instance_._instance,
  &::pb::_GetBlocksReply_default_instance_._instance,
  &::pb::_StateRequest_default_instance_._instance,
  &::pb::_StateNode_default_instance_._instance,
  &::pb::_GetStates_default_instance_._instance,
  &::pb::_GetStatesReply_default_instance_._instance,
  &::pb::_Relay_default_instance_._instance,
  &::pb::_Transactions_default_instance_._instance,
  &::pb::_BacktrackSignatureChain_default_instance_._instance,
  &::pb::_IHaveSignatureChainTransaction_default_instance_._instance,
  &::pb::_RequestSignatureChainTransaction_default_instance_._instance,
  &::pb::_RequestSignatureChainTransactionReply_default_instance_._instance,
  &::pb::_PinSignatureChain_default_instance_._instance,
  &::pb::_SignatureChainObjectionUnsigned_default_instance_._instance,
  &::pb::_SignatureChainObjectionSigned_default_instance_._instance,
};

const char descriptor_table_protodef_pb_2fnodemessage_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\024pb/nodemessage.proto\022\002pb\032\rpb/node.prot"
  "o\032\021pb/sigchain.proto\032\016pb/block.proto\032\024pb"
  "/transaction.proto\"I\n\017UnsignedMessage\022%\n"
  "\014message_type\030\001 \001(\0162\017.pb.MessageType\022\017\n\007"
  "message\030\002 \001(\014\"3\n\rSignedMessage\022\017\n\007messag"
  "e\030\001 \001(\014\022\021\n\tsignature\030\002 \001(\014\"*\n\004Vote\022\016\n\006he"
  "ight\030\001 \001(\r\022\022\n\nblock_hash\030\002 \001(\014\"8\n\022IHaveB"
  "lockProposal\022\016\n\006height\030\001 \001(\r\022\022\n\nblock_ha"
  "sh\030\002 \001(\014\"\206\001\n\024RequestBlockProposal\022\022\n\nblo"
  "ck_hash\030\001 \001(\014\022(\n\004type\030\002 \001(\0162\032.pb.Request"
  "TransactionType\022\027\n\017short_hash_salt\030\003 \001(\014"
  "\022\027\n\017short_hash_size\030\004 \001(\r\"P\n\031RequestBloc"
  "kProposalReply\022\030\n\005block\030\001 \001(\0132\t.pb.Block"
  "\022\031\n\021transactions_hash\030\002 \003(\014\"\250\001\n\033RequestP"
  "roposalTransactions\022\022\n\nblock_hash\030\001 \001(\014\022"
  "(\n\004type\030\002 \001(\0162\032.pb.RequestTransactionTyp"
  "e\022\027\n\017short_hash_salt\030\003 \001(\014\022\027\n\017short_hash"
  "_size\030\004 \001(\r\022\031\n\021transactions_hash\030\005 \003(\014\"I"
  "\n RequestProposalTransactionsReply\022%\n\014tr"
  "ansactions\030\001 \003(\0132\017.pb.Transaction\"\023\n\021Get"
  "ConsensusState\"\246\001\n\026GetConsensusStateRepl"
  "y\022\031\n\021ledger_block_hash\030\002 \001(\014\022\025\n\rledger_h"
  "eight\030\001 \001(\r\022\030\n\020consensus_height\030\003 \001(\r\022\035\n"
  "\025min_verifiable_height\030\005 \001(\r\022!\n\nsync_sta"
  "te\030\004 \001(\0162\r.pb.SyncState\";\n\017GetBlockHeade"
  "rs\022\024\n\014start_height\030\001 \001(\r\022\022\n\nend_height\030\002"
  " \001(\r\"9\n\024GetBlockHeadersReply\022!\n\rblock_he"
  "aders\030\001 \003(\0132\n.pb.Header\"5\n\tGetBlocks\022\024\n\014"
  "start_height\030\001 \001(\r\022\022\n\nend_height\030\002 \001(\r\"+"
  "\n\016GetBlocksReply\022\031\n\006blocks\030\001 \003(\0132\t.pb.Bl"
  "ock\"\034\n\014StateRequest\022\014\n\004hash\030\001 \001(\014\"\031\n\tSta"
  "teNode\022\014\n\004node\030\001 \001(\014\"+\n\tGetStates\022\036\n\004req"
  "s\030\001 \003(\0132\020.pb.StateRequest\".\n\016GetStatesRe"
  "ply\022\034\n\005nodes\030\001 \003(\0132\r.pb.StateNode\"\260\001\n\005Re"
  "lay\022\026\n\016src_identifier\030\001 \001(\t\022\022\n\nsrc_pubke"
  "y\030\006 \001(\014\022\017\n\007dest_id\030\002 \001(\014\022\017\n\007payload\030\003 \001("
  "\014\022\033\n\023max_holding_seconds\030\005 \001(\r\022\022\n\nblock_"
  "hash\030\007 \001(\014\022\021\n\tlast_hash\030\010 \001(\014\022\025\n\rsig_cha"
  "in_len\030\t \001(\r\"5\n\014Transactions\022%\n\014transact"
  "ions\030\001 \003(\0132\017.pb.Transaction\"R\n\027Backtrack"
  "SignatureChain\022)\n\017sig_chain_elems\030\001 \003(\0132"
  "\020.pb.SigChainElem\022\014\n\004hash\030\002 \001(\014\"H\n\036IHave"
  "SignatureChainTransaction\022\016\n\006height\030\001 \001("
  "\r\022\026\n\016signature_hash\030\002 \001(\014\":\n RequestSign"
  "atureChainTransaction\022\026\n\016signature_hash\030"
  "\001 \001(\014\"M\n%RequestSignatureChainTransactio"
  "nReply\022$\n\013transaction\030\001 \001(\0132\017.pb.Transac"
  "tion\"!\n\021PinSignatureChain\022\014\n\004hash\030\001 \001(\014\""
  "b\n\037SignatureChainObjectionUnsigned\022\016\n\006he"
  "ight\030\001 \001(\r\022\026\n\016signature_hash\030\002 \001(\014\022\027\n\017re"
  "porter_pubkey\030\003 \001(\014\"C\n\035SignatureChainObj"
  "ectionSigned\022\017\n\007message\030\001 \001(\014\022\021\n\tsignatu"
  "re\030\002 \001(\014*\221\005\n\013MessageType\022\'\n#MESSAGE_TYPE"
  "_PLACEHOLDER_DO_NOT_USE\020\000\022\010\n\004VOTE\020\001\022\031\n\025I"
  "_HAVE_BLOCK_PROPOSAL\020\002\022\032\n\026REQUEST_BLOCK_"
  "PROPOSAL\020\003\022 \n\034REQUEST_BLOCK_PROPOSAL_REP"
  "LY\020\004\022\027\n\023GET_CONSENSUS_STATE\020\005\022\035\n\031GET_CON"
  "SENSUS_STATE_REPLY\020\006\022\025\n\021GET_BLOCK_HEADER"
  "S\020\007\022\033\n\027GET_BLOCK_HEADERS_REPLY\020\010\022\016\n\nGET_"
  "BLOCKS\020\t\022\024\n\020GET_BLOCKS_REPLY\020\n\022\t\n\005RELAY\020"
  "\013\022\020\n\014TRANSACTIONS\020\014\022\035\n\031BACKTRACK_SIGNATU"
  "RE_CHAIN\020\r\022!\n\035REQUEST_PROPOSAL_TRANSACTI"
  "ONS\020\016\022\'\n#REQUEST_PROPOSAL_TRANSACTIONS_R"
  "EPLY\020\017\022&\n\"I_HAVE_SIGNATURE_CHAIN_TRANSAC"
  "TION\020\020\022\'\n#REQUEST_SIGNATURE_CHAIN_TRANSA"
  "CTION\020\021\022-\n)REQUEST_SIGNATURE_CHAIN_TRANS"
  "ACTION_REPLY\020\022\022\027\n\023PIN_SIGNATURE_CHAIN\020\023\022"
  "\035\n\031SIGNATURE_CHAIN_OBJECTION\020\024\022\016\n\nGET_ST"
  "ATES\020\025\022\024\n\020GET_STATES_REPLY\020\026*C\n\030AllowedS"
  "ignedMessageType\022\'\n#ALLOW_SIGNED_PLACEHO"
  "LDER_DO_NOT_USE\020\000*\343\007\n\032AllowedUnsignedMes"
  "sageType\022)\n%ALLOW_UNSIGNED_PLACEHOLDER_D"
  "O_NOT_USE\020\000\022\027\n\023ALLOW_UNSIGNED_VOTE\020\001\022(\n$"
  "ALLOW_UNSIGNED_I_HAVE_BLOCK_PROPOSAL\020\002\022)"
  "\n%ALLOW_UNSIGNED_REQUEST_BLOCK_PROPOSAL\020"
  "\003\022&\n\"ALLOW_UNSIGNED_REQUEST_BLOCK_REPLY\020"
  "\004\022&\n\"ALLOW_UNSIGNED_GET_CONSENSUS_STATE\020"
  "\005\022,\n(ALLOW_UNSIGNED_GET_CONSENSUS_STATE_"
  "REPLY\020\006\022$\n ALLOW_UNSIGNED_GET_BLOCK_HEAD"
  "ERS\020\007\022*\n&ALLOW_UNSIGNED_GET_BLOCK_HEADER"
  "S_REPLY\020\010\022\035\n\031ALLOW_UNSIGNED_GET_BLOCKS\020\t"
  "\022#\n\037ALLOW_UNSIGNED_GET_BLOCKS_REPLY\020\n\022\030\n"
  "\024ALLOW_UNSIGNED_RELAY\020\013\022\037\n\033ALLOW_UNSIGNE"
  "D_TRANSACTIONS\020\014\022,\n(ALLOW_UNSIGNED_BACKT"
  "RACK_SIGNATURE_CHAIN\020\r\0220\n,ALLOW_UNSIGNED"
  "_REQUEST_PROPOSAL_TRANSACTIONS\020\016\0226\n2ALLO"
  "W_UNSIGNED_REQUEST_PROPOSAL_TRANSACTIONS"
  "_REPLY\020\017\0225\n1ALLOW_UNSIGNED_I_HAVE_SIGNAT"
  "URE_CHAIN_TRANSACTION\020\020\0226\n2ALLOW_UNSIGNE"
  "D_REQUEST_SIGNATURE_CHAIN_TRANSACTION\020\021\022"
  "<\n8ALLOW_UNSIGNED_REQUEST_SIGNATURE_CHAI"
  "N_TRANSACTION_REPLY\020\022\022&\n\"ALLOW_UNSIGNED_"
  "PIN_SIGNATURE_CHAIN\020\023\022,\n(ALLOW_UNSIGNED_"
  "SIGNATURE_CHAIN_OBJECTION\020\024\022\035\n\031ALLOW_UNS"
  "IGNED_GET_STATES\020\025\022#\n\037ALLOW_UNSIGNED_GET"
  "_STATES_REPLY\020\026*\374\006\n\030AllowedDirectMessage"
  "Type\022\'\n#ALLOW_DIRECT_PLACEHOLDER_DO_NOT_"
  "USE\020\000\022\025\n\021ALLOW_DIRECT_VOTE\020\001\022&\n\"ALLOW_DI"
  "RECT_I_HAVE_BLOCK_PROPOSAL\020\002\022\'\n#ALLOW_DI"
  "RECT_REQUEST_BLOCK_PROPOSAL\020\003\022$\n ALLOW_D"
  "IRECT_REQUEST_BLOCK_REPLY\020\004\022$\n ALLOW_DIR"
  "ECT_GET_CONSENSUS_STATE\020\005\022*\n&ALLOW_DIREC"
  "T_GET_CONSENSUS_STATE_REPLY\020\006\022\"\n\036ALLOW_D"
  "IRECT_GET_BLOCK_HEADERS\020\007\022(\n$ALLOW_DIREC"
  "T_GET_BLOCK_HEADERS_REPLY\020\010\022\033\n\027ALLOW_DIR"
  "ECT_GET_BLOCKS\020\t\022!\n\035ALLOW_DIRECT_GET_BLO"
  "CKS_REPLY\020\n\022*\n&ALLOW_DIRECT_BACKTRACK_SI"
  "GNATURE_CHAIN\020\r\022.\n*ALLOW_DIRECT_REQUEST_"
  "PROPOSAL_TRANSACTIONS\020\016\0224\n0ALLOW_DIRECT_"
  "REQUEST_PROPOSAL_TRANSACTIONS_REPLY\020\017\0223\n"
  "/ALLOW_DIRECT_I_HAVE_SIGNATURE_CHAIN_TRA"
  "NSACTION\020\020\0224\n0ALLOW_DIRECT_REQUEST_SIGNA"
  "TURE_CHAIN_TRANSACTION\020\021\022:\n6ALLOW_DIRECT"
  "_REQUEST_SIGNATURE_CHAIN_TRANSACTION_REP"
  "LY\020\022\022$\n ALLOW_DIRECT_PIN_SIGNATURE_CHAIN"
  "\020\023\022*\n&ALLOW_DIRECT_SIGNATURE_CHAIN_OBJEC"
  "TION\020\024\022\033\n\027ALLOW_DIRECT_GET_STATES\020\025\022!\n\035A"
  "LLOW_DIRECT_GET_STATES_REPLY\020\026*X\n\027Allowe"
  "dRelayMessageType\022&\n\"ALLOW_RELAY_PLACEHO"
  "LDER_DO_NOT_USE\020\000\022\025\n\021ALLOW_RELAY_RELAY\020\013"
  "*y\n\037AllowedBroadcastPushMessageType\022/\n+A"
  "LLOW_BROADCAST_PUSH_PLACEHOLDER_DO_NOT_U"
  "SE\020\000\022%\n!ALLOW_BROADCAST_PUSH_TRANSACTION"
  "S\020\014*R\n\037AllowedBroadcastPullMessageType\022/"
  "\n+ALLOW_BROADCAST_PULL_PLACEHOLDER_DO_NO"
  "T_USE\020\000*y\n\037AllowedBroadcastTreeMessageTy"
  "pe\022/\n+ALLOW_BROADCAST_TREE_PLACEHOLDER_D"
  "O_NOT_USE\020\000\022%\n!ALLOW_BROADCAST_TREE_TRAN"
  "SACTIONS\020\014*x\n\026RequestTransactionType\022\034\n\030"
  "REQUEST_FULL_TRANSACTION\020\000\022\034\n\030REQUEST_TR"
  "ANSACTION_HASH\020\001\022\"\n\036REQUEST_TRANSACTION_"
  "SHORT_HASH\020\002B\006Z\004./pbb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_pb_2fnodemessage_2eproto_deps[4] = {
  &::descriptor_table_pb_2fblock_2eproto,
  &::descriptor_table_pb_2fnode_2eproto,
  &::descriptor_table_pb_2fsigchain_2eproto,
  &::descriptor_table_pb_2ftransaction_2eproto,
};
static ::_pbi::once_flag descriptor_table_pb_2fnodemessage_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_pb_2fnodemessage_2eproto = {
    false, false, 5268, descriptor_table_protodef_pb_2fnodemessage_2eproto,
    "pb/nodemessage.proto",
    &descriptor_table_pb_2fnodemessage_2eproto_once, descriptor_table_pb_2fnodemessage_2eproto_deps, 4, 27,
    schemas, file_default_instances, TableStruct_pb_2fnodemessage_2eproto::offsets,
    file_level_metadata_pb_2fnodemessage_2eproto, file_level_enum_descriptors_pb_2fnodemessage_2eproto,
    file_level_service_descriptors_pb_2fnodemessage_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_pb_2fnodemessage_2eproto_getter() {
  return &descriptor_table_pb_2fnodemessage_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_pb_2fnodemessage_2eproto(&descriptor_table_pb_2fnodemessage_2eproto);
namespace pb {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_pb_2fnodemessage_2eproto);
  return file_level_enum_descriptors_pb_2fnodemessage_2eproto[0];
}
bool MessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AllowedSignedMessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_pb_2fnodemessage_2eproto);
  return file_level_enum_descriptors_pb_2fnodemessage_2eproto[1];
}
bool AllowedSignedMessageType_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AllowedUnsignedMessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_pb_2fnodemessage_2eproto);
  return file_level_enum_descriptors_pb_2fnodemessage_2eproto[2];
}
bool AllowedUnsignedMessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AllowedDirectMessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_pb_2fnodemessage_2eproto);
  return file_level_enum_descriptors_pb_2fnodemessage_2eproto[3];
}
bool AllowedDirectMessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AllowedRelayMessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_pb_2fnodemessage_2eproto);
  return file_level_enum_descriptors_pb_2fnodemessage_2eproto[4];
}
bool AllowedRelayMessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 11:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AllowedBroadcastPushMessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_pb_2fnodemessage_2eproto);
  return file_level_enum_descriptors_pb_2fnodemessage_2eproto[5];
}
bool AllowedBroadcastPushMessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 12:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AllowedBroadcastPullMessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_pb_2fnodemessage_2eproto);
  return file_level_enum_descriptors_pb_2fnodemessage_2eproto[6];
}
bool AllowedBroadcastPullMessageType_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AllowedBroadcastTreeMessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_pb_2fnodemessage_2eproto);
  return file_level_enum_descriptors_pb_2fnodemessage_2eproto[7];
}
bool AllowedBroadcastTreeMessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 12:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestTransactionType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_pb_2fnodemessage_2eproto);
  return file_level_enum_descriptors_pb_2fnodemessage_2eproto[8];
}
bool RequestTransactionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class UnsignedMessage::_Internal {
 public:
};

UnsignedMessage::UnsignedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.UnsignedMessage)
}
UnsignedMessage::UnsignedMessage(const UnsignedMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UnsignedMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.message_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.message_type_ = from._impl_.message_type_;
  // @@protoc_insertion_point(copy_constructor:pb.UnsignedMessage)
}

inline void UnsignedMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.message_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UnsignedMessage::~UnsignedMessage() {
  // @@protoc_insertion_point(destructor:pb.UnsignedMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UnsignedMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void UnsignedMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UnsignedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.UnsignedMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _impl_.message_type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UnsignedMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .pb.MessageType message_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_message_type(static_cast<::pb::MessageType>(val));
        } else
          goto handle_unusual;
        continue;
      // bytes message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnsignedMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.UnsignedMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .pb.MessageType message_type = 1;
  if (this->_internal_message_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_message_type(), target);
  }

  // bytes message = 2;
  if (!this->_internal_message().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.UnsignedMessage)
  return target;
}

size_t UnsignedMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.UnsignedMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes message = 2;
  if (!this->_internal_message().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_message());
  }

  // .pb.MessageType message_type = 1;
  if (this->_internal_message_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_message_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UnsignedMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UnsignedMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UnsignedMessage::GetClassData() const { return &_class_data_; }


void UnsignedMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UnsignedMessage*>(&to_msg);
  auto& from = static_cast<const UnsignedMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.UnsignedMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  if (from._internal_message_type() != 0) {
    _this->_internal_set_message_type(from._internal_message_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UnsignedMessage::CopyFrom(const UnsignedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.UnsignedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnsignedMessage::IsInitialized() const {
  return true;
}

void UnsignedMessage::InternalSwap(UnsignedMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  swap(_impl_.message_type_, other->_impl_.message_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UnsignedMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[0]);
}

// ===================================================================

class SignedMessage::_Internal {
 public:
};

SignedMessage::SignedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.SignedMessage)
}
SignedMessage::SignedMessage(const SignedMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SignedMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.signature_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_signature().empty()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:pb.SignedMessage)
}

inline void SignedMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.signature_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SignedMessage::~SignedMessage() {
  // @@protoc_insertion_point(destructor:pb.SignedMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SignedMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
  _impl_.signature_.Destroy();
}

void SignedMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SignedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.SignedMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _impl_.signature_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignedMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes signature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SignedMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.SignedMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes message = 1;
  if (!this->_internal_message().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_message(), target);
  }

  // bytes signature = 2;
  if (!this->_internal_signature().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.SignedMessage)
  return target;
}

size_t SignedMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.SignedMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes message = 1;
  if (!this->_internal_message().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_message());
  }

  // bytes signature = 2;
  if (!this->_internal_signature().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignedMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SignedMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignedMessage::GetClassData() const { return &_class_data_; }


void SignedMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SignedMessage*>(&to_msg);
  auto& from = static_cast<const SignedMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.SignedMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  if (!from._internal_signature().empty()) {
    _this->_internal_set_signature(from._internal_signature());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignedMessage::CopyFrom(const SignedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.SignedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignedMessage::IsInitialized() const {
  return true;
}

void SignedMessage::InternalSwap(SignedMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SignedMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[1]);
}

// ===================================================================

class Vote::_Internal {
 public:
};

Vote::Vote(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.Vote)
}
Vote::Vote(const Vote& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Vote* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.block_hash_){}
    , decltype(_impl_.height_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.block_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_block_hash().empty()) {
    _this->_impl_.block_hash_.Set(from._internal_block_hash(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.height_ = from._impl_.height_;
  // @@protoc_insertion_point(copy_constructor:pb.Vote)
}

inline void Vote::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.block_hash_){}
    , decltype(_impl_.height_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.block_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Vote::~Vote() {
  // @@protoc_insertion_point(destructor:pb.Vote)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Vote::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.block_hash_.Destroy();
}

void Vote::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Vote::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.Vote)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.block_hash_.ClearToEmpty();
  _impl_.height_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vote::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 height = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes block_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_block_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Vote::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.Vote)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 height = 1;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_height(), target);
  }

  // bytes block_hash = 2;
  if (!this->_internal_block_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_block_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.Vote)
  return target;
}

size_t Vote::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.Vote)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes block_hash = 2;
  if (!this->_internal_block_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_block_hash());
  }

  // uint32 height = 1;
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Vote::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Vote::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Vote::GetClassData() const { return &_class_data_; }


void Vote::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Vote*>(&to_msg);
  auto& from = static_cast<const Vote&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.Vote)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_block_hash().empty()) {
    _this->_internal_set_block_hash(from._internal_block_hash());
  }
  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Vote::CopyFrom(const Vote& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.Vote)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vote::IsInitialized() const {
  return true;
}

void Vote::InternalSwap(Vote* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.block_hash_, lhs_arena,
      &other->_impl_.block_hash_, rhs_arena
  );
  swap(_impl_.height_, other->_impl_.height_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Vote::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[2]);
}

// ===================================================================

class IHaveBlockProposal::_Internal {
 public:
};

IHaveBlockProposal::IHaveBlockProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.IHaveBlockProposal)
}
IHaveBlockProposal::IHaveBlockProposal(const IHaveBlockProposal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IHaveBlockProposal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.block_hash_){}
    , decltype(_impl_.height_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.block_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_block_hash().empty()) {
    _this->_impl_.block_hash_.Set(from._internal_block_hash(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.height_ = from._impl_.height_;
  // @@protoc_insertion_point(copy_constructor:pb.IHaveBlockProposal)
}

inline void IHaveBlockProposal::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.block_hash_){}
    , decltype(_impl_.height_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.block_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IHaveBlockProposal::~IHaveBlockProposal() {
  // @@protoc_insertion_point(destructor:pb.IHaveBlockProposal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IHaveBlockProposal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.block_hash_.Destroy();
}

void IHaveBlockProposal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IHaveBlockProposal::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.IHaveBlockProposal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.block_hash_.ClearToEmpty();
  _impl_.height_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IHaveBlockProposal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 height = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes block_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_block_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IHaveBlockProposal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.IHaveBlockProposal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 height = 1;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_height(), target);
  }

  // bytes block_hash = 2;
  if (!this->_internal_block_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_block_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.IHaveBlockProposal)
  return target;
}

size_t IHaveBlockProposal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.IHaveBlockProposal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes block_hash = 2;
  if (!this->_internal_block_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_block_hash());
  }

  // uint32 height = 1;
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IHaveBlockProposal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IHaveBlockProposal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IHaveBlockProposal::GetClassData() const { return &_class_data_; }


void IHaveBlockProposal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IHaveBlockProposal*>(&to_msg);
  auto& from = static_cast<const IHaveBlockProposal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.IHaveBlockProposal)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_block_hash().empty()) {
    _this->_internal_set_block_hash(from._internal_block_hash());
  }
  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IHaveBlockProposal::CopyFrom(const IHaveBlockProposal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.IHaveBlockProposal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IHaveBlockProposal::IsInitialized() const {
  return true;
}

void IHaveBlockProposal::InternalSwap(IHaveBlockProposal* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.block_hash_, lhs_arena,
      &other->_impl_.block_hash_, rhs_arena
  );
  swap(_impl_.height_, other->_impl_.height_);
}

::PROTOBUF_NAMESPACE_ID::Metadata IHaveBlockProposal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[3]);
}

// ===================================================================

class RequestBlockProposal::_Internal {
 public:
};

RequestBlockProposal::RequestBlockProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.RequestBlockProposal)
}
RequestBlockProposal::RequestBlockProposal(const RequestBlockProposal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestBlockProposal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.block_hash_){}
    , decltype(_impl_.short_hash_salt_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.short_hash_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.block_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_block_hash().empty()) {
    _this->_impl_.block_hash_.Set(from._internal_block_hash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.short_hash_salt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.short_hash_salt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_short_hash_salt().empty()) {
    _this->_impl_.short_hash_salt_.Set(from._internal_short_hash_salt(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.short_hash_size_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.short_hash_size_));
  // @@protoc_insertion_point(copy_constructor:pb.RequestBlockProposal)
}

inline void RequestBlockProposal::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.block_hash_){}
    , decltype(_impl_.short_hash_salt_){}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.short_hash_size_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.block_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.short_hash_salt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.short_hash_salt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RequestBlockProposal::~RequestBlockProposal() {
  // @@protoc_insertion_point(destructor:pb.RequestBlockProposal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestBlockProposal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.block_hash_.Destroy();
  _impl_.short_hash_salt_.Destroy();
}

void RequestBlockProposal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestBlockProposal::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.RequestBlockProposal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.block_hash_.ClearToEmpty();
  _impl_.short_hash_salt_.ClearToEmpty();
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.short_hash_size_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.short_hash_size_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestBlockProposal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes block_hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_block_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .pb.RequestTransactionType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::pb::RequestTransactionType>(val));
        } else
          goto handle_unusual;
        continue;
      // bytes short_hash_salt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_short_hash_salt();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 short_hash_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.short_hash_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestBlockProposal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.RequestBlockProposal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes block_hash = 1;
  if (!this->_internal_block_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_block_hash(), target);
  }

  // .pb.RequestTransactionType type = 2;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // bytes short_hash_salt = 3;
  if (!this->_internal_short_hash_salt().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_short_hash_salt(), target);
  }

  // uint32 short_hash_size = 4;
  if (this->_internal_short_hash_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_short_hash_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.RequestBlockProposal)
  return target;
}

size_t RequestBlockProposal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.RequestBlockProposal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes block_hash = 1;
  if (!this->_internal_block_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_block_hash());
  }

  // bytes short_hash_salt = 3;
  if (!this->_internal_short_hash_salt().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_short_hash_salt());
  }

  // .pb.RequestTransactionType type = 2;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // uint32 short_hash_size = 4;
  if (this->_internal_short_hash_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_short_hash_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestBlockProposal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestBlockProposal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestBlockProposal::GetClassData() const { return &_class_data_; }


void RequestBlockProposal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestBlockProposal*>(&to_msg);
  auto& from = static_cast<const RequestBlockProposal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.RequestBlockProposal)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_block_hash().empty()) {
    _this->_internal_set_block_hash(from._internal_block_hash());
  }
  if (!from._internal_short_hash_salt().empty()) {
    _this->_internal_set_short_hash_salt(from._internal_short_hash_salt());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_short_hash_size() != 0) {
    _this->_internal_set_short_hash_size(from._internal_short_hash_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestBlockProposal::CopyFrom(const RequestBlockProposal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.RequestBlockProposal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestBlockProposal::IsInitialized() const {
  return true;
}

void RequestBlockProposal::InternalSwap(RequestBlockProposal* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.block_hash_, lhs_arena,
      &other->_impl_.block_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.short_hash_salt_, lhs_arena,
      &other->_impl_.short_hash_salt_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RequestBlockProposal, _impl_.short_hash_size_)
      + sizeof(RequestBlockProposal::_impl_.short_hash_size_)
      - PROTOBUF_FIELD_OFFSET(RequestBlockProposal, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestBlockProposal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[4]);
}

// ===================================================================

class RequestBlockProposalReply::_Internal {
 public:
  static const ::pb::Block& block(const RequestBlockProposalReply* msg);
};

const ::pb::Block&
RequestBlockProposalReply::_Internal::block(const RequestBlockProposalReply* msg) {
  return *msg->_impl_.block_;
}
void RequestBlockProposalReply::clear_block() {
  if (GetArenaForAllocation() == nullptr && _impl_.block_ != nullptr) {
    delete _impl_.block_;
  }
  _impl_.block_ = nullptr;
}
RequestBlockProposalReply::RequestBlockProposalReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.RequestBlockProposalReply)
}
RequestBlockProposalReply::RequestBlockProposalReply(const RequestBlockProposalReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestBlockProposalReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transactions_hash_){from._impl_.transactions_hash_}
    , decltype(_impl_.block_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_block()) {
    _this->_impl_.block_ = new ::pb::Block(*from._impl_.block_);
  }
  // @@protoc_insertion_point(copy_constructor:pb.RequestBlockProposalReply)
}

inline void RequestBlockProposalReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.transactions_hash_){arena}
    , decltype(_impl_.block_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RequestBlockProposalReply::~RequestBlockProposalReply() {
  // @@protoc_insertion_point(destructor:pb.RequestBlockProposalReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestBlockProposalReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transactions_hash_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.block_;
}

void RequestBlockProposalReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestBlockProposalReply::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.RequestBlockProposalReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transactions_hash_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.block_ != nullptr) {
    delete _impl_.block_;
  }
  _impl_.block_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestBlockProposalReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .pb.Block block = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_block(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes transactions_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_transactions_hash();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestBlockProposalReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.RequestBlockProposalReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .pb.Block block = 1;
  if (this->_internal_has_block()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::block(this),
        _Internal::block(this).GetCachedSize(), target, stream);
  }

  // repeated bytes transactions_hash = 2;
  for (int i = 0, n = this->_internal_transactions_hash_size(); i < n; i++) {
    const auto& s = this->_internal_transactions_hash(i);
    target = stream->WriteBytes(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.RequestBlockProposalReply)
  return target;
}

size_t RequestBlockProposalReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.RequestBlockProposalReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes transactions_hash = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.transactions_hash_.size());
  for (int i = 0, n = _impl_.transactions_hash_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.transactions_hash_.Get(i));
  }

  // .pb.Block block = 1;
  if (this->_internal_has_block()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.block_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestBlockProposalReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestBlockProposalReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestBlockProposalReply::GetClassData() const { return &_class_data_; }


void RequestBlockProposalReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestBlockProposalReply*>(&to_msg);
  auto& from = static_cast<const RequestBlockProposalReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.RequestBlockProposalReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.transactions_hash_.MergeFrom(from._impl_.transactions_hash_);
  if (from._internal_has_block()) {
    _this->_internal_mutable_block()->::pb::Block::MergeFrom(
        from._internal_block());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestBlockProposalReply::CopyFrom(const RequestBlockProposalReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.RequestBlockProposalReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestBlockProposalReply::IsInitialized() const {
  return true;
}

void RequestBlockProposalReply::InternalSwap(RequestBlockProposalReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.transactions_hash_.InternalSwap(&other->_impl_.transactions_hash_);
  swap(_impl_.block_, other->_impl_.block_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestBlockProposalReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[5]);
}

// ===================================================================

class RequestProposalTransactions::_Internal {
 public:
};

RequestProposalTransactions::RequestProposalTransactions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.RequestProposalTransactions)
}
RequestProposalTransactions::RequestProposalTransactions(const RequestProposalTransactions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestProposalTransactions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transactions_hash_){from._impl_.transactions_hash_}
    , decltype(_impl_.block_hash_){}
    , decltype(_impl_.short_hash_salt_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.short_hash_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.block_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_block_hash().empty()) {
    _this->_impl_.block_hash_.Set(from._internal_block_hash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.short_hash_salt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.short_hash_salt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_short_hash_salt().empty()) {
    _this->_impl_.short_hash_salt_.Set(from._internal_short_hash_salt(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.short_hash_size_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.short_hash_size_));
  // @@protoc_insertion_point(copy_constructor:pb.RequestProposalTransactions)
}

inline void RequestProposalTransactions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.transactions_hash_){arena}
    , decltype(_impl_.block_hash_){}
    , decltype(_impl_.short_hash_salt_){}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.short_hash_size_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.block_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.short_hash_salt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.short_hash_salt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RequestProposalTransactions::~RequestProposalTransactions() {
  // @@protoc_insertion_point(destructor:pb.RequestProposalTransactions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestProposalTransactions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transactions_hash_.~RepeatedPtrField();
  _impl_.block_hash_.Destroy();
  _impl_.short_hash_salt_.Destroy();
}

void RequestProposalTransactions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestProposalTransactions::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.RequestProposalTransactions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transactions_hash_.Clear();
  _impl_.block_hash_.ClearToEmpty();
  _impl_.short_hash_salt_.ClearToEmpty();
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.short_hash_size_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.short_hash_size_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestProposalTransactions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes block_hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_block_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .pb.RequestTransactionType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::pb::RequestTransactionType>(val));
        } else
          goto handle_unusual;
        continue;
      // bytes short_hash_salt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_short_hash_salt();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 short_hash_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.short_hash_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes transactions_hash = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_transactions_hash();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestProposalTransactions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.RequestProposalTransactions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes block_hash = 1;
  if (!this->_internal_block_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_block_hash(), target);
  }

  // .pb.RequestTransactionType type = 2;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // bytes short_hash_salt = 3;
  if (!this->_internal_short_hash_salt().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_short_hash_salt(), target);
  }

  // uint32 short_hash_size = 4;
  if (this->_internal_short_hash_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_short_hash_size(), target);
  }

  // repeated bytes transactions_hash = 5;
  for (int i = 0, n = this->_internal_transactions_hash_size(); i < n; i++) {
    const auto& s = this->_internal_transactions_hash(i);
    target = stream->WriteBytes(5, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.RequestProposalTransactions)
  return target;
}

size_t RequestProposalTransactions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.RequestProposalTransactions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes transactions_hash = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.transactions_hash_.size());
  for (int i = 0, n = _impl_.transactions_hash_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.transactions_hash_.Get(i));
  }

  // bytes block_hash = 1;
  if (!this->_internal_block_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_block_hash());
  }

  // bytes short_hash_salt = 3;
  if (!this->_internal_short_hash_salt().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_short_hash_salt());
  }

  // .pb.RequestTransactionType type = 2;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // uint32 short_hash_size = 4;
  if (this->_internal_short_hash_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_short_hash_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestProposalTransactions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestProposalTransactions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestProposalTransactions::GetClassData() const { return &_class_data_; }


void RequestProposalTransactions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestProposalTransactions*>(&to_msg);
  auto& from = static_cast<const RequestProposalTransactions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.RequestProposalTransactions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.transactions_hash_.MergeFrom(from._impl_.transactions_hash_);
  if (!from._internal_block_hash().empty()) {
    _this->_internal_set_block_hash(from._internal_block_hash());
  }
  if (!from._internal_short_hash_salt().empty()) {
    _this->_internal_set_short_hash_salt(from._internal_short_hash_salt());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_short_hash_size() != 0) {
    _this->_internal_set_short_hash_size(from._internal_short_hash_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestProposalTransactions::CopyFrom(const RequestProposalTransactions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.RequestProposalTransactions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestProposalTransactions::IsInitialized() const {
  return true;
}

void RequestProposalTransactions::InternalSwap(RequestProposalTransactions* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.transactions_hash_.InternalSwap(&other->_impl_.transactions_hash_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.block_hash_, lhs_arena,
      &other->_impl_.block_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.short_hash_salt_, lhs_arena,
      &other->_impl_.short_hash_salt_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RequestProposalTransactions, _impl_.short_hash_size_)
      + sizeof(RequestProposalTransactions::_impl_.short_hash_size_)
      - PROTOBUF_FIELD_OFFSET(RequestProposalTransactions, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestProposalTransactions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[6]);
}

// ===================================================================

class RequestProposalTransactionsReply::_Internal {
 public:
};

void RequestProposalTransactionsReply::clear_transactions() {
  _impl_.transactions_.Clear();
}
RequestProposalTransactionsReply::RequestProposalTransactionsReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.RequestProposalTransactionsReply)
}
RequestProposalTransactionsReply::RequestProposalTransactionsReply(const RequestProposalTransactionsReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestProposalTransactionsReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transactions_){from._impl_.transactions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb.RequestProposalTransactionsReply)
}

inline void RequestProposalTransactionsReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.transactions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RequestProposalTransactionsReply::~RequestProposalTransactionsReply() {
  // @@protoc_insertion_point(destructor:pb.RequestProposalTransactionsReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestProposalTransactionsReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transactions_.~RepeatedPtrField();
}

void RequestProposalTransactionsReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestProposalTransactionsReply::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.RequestProposalTransactionsReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transactions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestProposalTransactionsReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .pb.Transaction transactions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_transactions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestProposalTransactionsReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.RequestProposalTransactionsReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pb.Transaction transactions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_transactions_size()); i < n; i++) {
    const auto& repfield = this->_internal_transactions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.RequestProposalTransactionsReply)
  return target;
}

size_t RequestProposalTransactionsReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.RequestProposalTransactionsReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.Transaction transactions = 1;
  total_size += 1UL * this->_internal_transactions_size();
  for (const auto& msg : this->_impl_.transactions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestProposalTransactionsReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestProposalTransactionsReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestProposalTransactionsReply::GetClassData() const { return &_class_data_; }


void RequestProposalTransactionsReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestProposalTransactionsReply*>(&to_msg);
  auto& from = static_cast<const RequestProposalTransactionsReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.RequestProposalTransactionsReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.transactions_.MergeFrom(from._impl_.transactions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestProposalTransactionsReply::CopyFrom(const RequestProposalTransactionsReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.RequestProposalTransactionsReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestProposalTransactionsReply::IsInitialized() const {
  return true;
}

void RequestProposalTransactionsReply::InternalSwap(RequestProposalTransactionsReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.transactions_.InternalSwap(&other->_impl_.transactions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestProposalTransactionsReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[7]);
}

// ===================================================================

class GetConsensusState::_Internal {
 public:
};

GetConsensusState::GetConsensusState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:pb.GetConsensusState)
}
GetConsensusState::GetConsensusState(const GetConsensusState& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  GetConsensusState* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb.GetConsensusState)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetConsensusState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetConsensusState::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata GetConsensusState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[8]);
}

// ===================================================================

class GetConsensusStateReply::_Internal {
 public:
};

GetConsensusStateReply::GetConsensusStateReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.GetConsensusStateReply)
}
GetConsensusStateReply::GetConsensusStateReply(const GetConsensusStateReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetConsensusStateReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ledger_block_hash_){}
    , decltype(_impl_.ledger_height_){}
    , decltype(_impl_.consensus_height_){}
    , decltype(_impl_.sync_state_){}
    , decltype(_impl_.min_verifiable_height_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ledger_block_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledger_block_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ledger_block_hash().empty()) {
    _this->_impl_.ledger_block_hash_.Set(from._internal_ledger_block_hash(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.ledger_height_, &from._impl_.ledger_height_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.min_verifiable_height_) -
    reinterpret_cast<char*>(&_impl_.ledger_height_)) + sizeof(_impl_.min_verifiable_height_));
  // @@protoc_insertion_point(copy_constructor:pb.GetConsensusStateReply)
}

inline void GetConsensusStateReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ledger_block_hash_){}
    , decltype(_impl_.ledger_height_){0u}
    , decltype(_impl_.consensus_height_){0u}
    , decltype(_impl_.sync_state_){0}
    , decltype(_impl_.min_verifiable_height_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ledger_block_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ledger_block_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetConsensusStateReply::~GetConsensusStateReply() {
  // @@protoc_insertion_point(destructor:pb.GetConsensusStateReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetConsensusStateReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ledger_block_hash_.Destroy();
}

void GetConsensusStateReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetConsensusStateReply::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.GetConsensusStateReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ledger_block_hash_.ClearToEmpty();
  ::memset(&_impl_.ledger_height_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.min_verifiable_height_) -
      reinterpret_cast<char*>(&_impl_.ledger_height_)) + sizeof(_impl_.min_verifiable_height_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetConsensusStateReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 ledger_height = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.ledger_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes ledger_block_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ledger_block_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 consensus_height = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.consensus_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .pb.SyncState sync_state = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_sync_state(static_cast<::pb::SyncState>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 min_verifiable_height = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.min_verifiable_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetConsensusStateReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.GetConsensusStateReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 ledger_height = 1;
  if (this->_internal_ledger_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ledger_height(), target);
  }

  // bytes ledger_block_hash = 2;
  if (!this->_internal_ledger_block_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_ledger_block_hash(), target);
  }

  // uint32 consensus_height = 3;
  if (this->_internal_consensus_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_consensus_height(), target);
  }

  // .pb.SyncState sync_state = 4;
  if (this->_internal_sync_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_sync_state(), target);
  }

  // uint32 min_verifiable_height = 5;
  if (this->_internal_min_verifiable_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_min_verifiable_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.GetConsensusStateReply)
  return target;
}

size_t GetConsensusStateReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.GetConsensusStateReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes ledger_block_hash = 2;
  if (!this->_internal_ledger_block_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledger_block_hash());
  }

  // uint32 ledger_height = 1;
  if (this->_internal_ledger_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ledger_height());
  }

  // uint32 consensus_height = 3;
  if (this->_internal_consensus_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_consensus_height());
  }

  // .pb.SyncState sync_state = 4;
  if (this->_internal_sync_state() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_sync_state());
  }

  // uint32 min_verifiable_height = 5;
  if (this->_internal_min_verifiable_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_min_verifiable_height());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetConsensusStateReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetConsensusStateReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetConsensusStateReply::GetClassData() const { return &_class_data_; }


void GetConsensusStateReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetConsensusStateReply*>(&to_msg);
  auto& from = static_cast<const GetConsensusStateReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.GetConsensusStateReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ledger_block_hash().empty()) {
    _this->_internal_set_ledger_block_hash(from._internal_ledger_block_hash());
  }
  if (from._internal_ledger_height() != 0) {
    _this->_internal_set_ledger_height(from._internal_ledger_height());
  }
  if (from._internal_consensus_height() != 0) {
    _this->_internal_set_consensus_height(from._internal_consensus_height());
  }
  if (from._internal_sync_state() != 0) {
    _this->_internal_set_sync_state(from._internal_sync_state());
  }
  if (from._internal_min_verifiable_height() != 0) {
    _this->_internal_set_min_verifiable_height(from._internal_min_verifiable_height());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetConsensusStateReply::CopyFrom(const GetConsensusStateReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.GetConsensusStateReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetConsensusStateReply::IsInitialized() const {
  return true;
}

void GetConsensusStateReply::InternalSwap(GetConsensusStateReply* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ledger_block_hash_, lhs_arena,
      &other->_impl_.ledger_block_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetConsensusStateReply, _impl_.min_verifiable_height_)
      + sizeof(GetConsensusStateReply::_impl_.min_verifiable_height_)
      - PROTOBUF_FIELD_OFFSET(GetConsensusStateReply, _impl_.ledger_height_)>(
          reinterpret_cast<char*>(&_impl_.ledger_height_),
          reinterpret_cast<char*>(&other->_impl_.ledger_height_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetConsensusStateReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[9]);
}

// ===================================================================

class GetBlockHeaders::_Internal {
 public:
};

GetBlockHeaders::GetBlockHeaders(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.GetBlockHeaders)
}
GetBlockHeaders::GetBlockHeaders(const GetBlockHeaders& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetBlockHeaders* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.start_height_){}
    , decltype(_impl_.end_height_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.start_height_, &from._impl_.start_height_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.end_height_) -
    reinterpret_cast<char*>(&_impl_.start_height_)) + sizeof(_impl_.end_height_));
  // @@protoc_insertion_point(copy_constructor:pb.GetBlockHeaders)
}

inline void GetBlockHeaders::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.start_height_){0u}
    , decltype(_impl_.end_height_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GetBlockHeaders::~GetBlockHeaders() {
  // @@protoc_insertion_point(destructor:pb.GetBlockHeaders)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetBlockHeaders::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetBlockHeaders::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetBlockHeaders::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.GetBlockHeaders)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.start_height_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.end_height_) -
      reinterpret_cast<char*>(&_impl_.start_height_)) + sizeof(_impl_.end_height_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetBlockHeaders::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 start_height = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.start_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 end_height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.end_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetBlockHeaders::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.GetBlockHeaders)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 start_height = 1;
  if (this->_internal_start_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_start_height(), target);
  }

  // uint32 end_height = 2;
  if (this->_internal_end_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_end_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.GetBlockHeaders)
  return target;
}

size_t GetBlockHeaders::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.GetBlockHeaders)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 start_height = 1;
  if (this->_internal_start_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_height());
  }

  // uint32 end_height = 2;
  if (this->_internal_end_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_height());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetBlockHeaders::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetBlockHeaders::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetBlockHeaders::GetClassData() const { return &_class_data_; }


void GetBlockHeaders::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetBlockHeaders*>(&to_msg);
  auto& from = static_cast<const GetBlockHeaders&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.GetBlockHeaders)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_start_height() != 0) {
    _this->_internal_set_start_height(from._internal_start_height());
  }
  if (from._internal_end_height() != 0) {
    _this->_internal_set_end_height(from._internal_end_height());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetBlockHeaders::CopyFrom(const GetBlockHeaders& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.GetBlockHeaders)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetBlockHeaders::IsInitialized() const {
  return true;
}

void GetBlockHeaders::InternalSwap(GetBlockHeaders* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetBlockHeaders, _impl_.end_height_)
      + sizeof(GetBlockHeaders::_impl_.end_height_)
      - PROTOBUF_FIELD_OFFSET(GetBlockHeaders, _impl_.start_height_)>(
          reinterpret_cast<char*>(&_impl_.start_height_),
          reinterpret_cast<char*>(&other->_impl_.start_height_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetBlockHeaders::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[10]);
}

// ===================================================================

class GetBlockHeadersReply::_Internal {
 public:
};

void GetBlockHeadersReply::clear_block_headers() {
  _impl_.block_headers_.Clear();
}
GetBlockHeadersReply::GetBlockHeadersReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.GetBlockHeadersReply)
}
GetBlockHeadersReply::GetBlockHeadersReply(const GetBlockHeadersReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetBlockHeadersReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.block_headers_){from._impl_.block_headers_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb.GetBlockHeadersReply)
}

inline void GetBlockHeadersReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.block_headers_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GetBlockHeadersReply::~GetBlockHeadersReply() {
  // @@protoc_insertion_point(destructor:pb.GetBlockHeadersReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetBlockHeadersReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.block_headers_.~RepeatedPtrField();
}

void GetBlockHeadersReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetBlockHeadersReply::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.GetBlockHeadersReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.block_headers_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetBlockHeadersReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .pb.Header block_headers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_block_headers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetBlockHeadersReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.GetBlockHeadersReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pb.Header block_headers = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_block_headers_size()); i < n; i++) {
    const auto& repfield = this->_internal_block_headers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.GetBlockHeadersReply)
  return target;
}

size_t GetBlockHeadersReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.GetBlockHeadersReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.Header block_headers = 1;
  total_size += 1UL * this->_internal_block_headers_size();
  for (const auto& msg : this->_impl_.block_headers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetBlockHeadersReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetBlockHeadersReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetBlockHeadersReply::GetClassData() const { return &_class_data_; }


void GetBlockHeadersReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetBlockHeadersReply*>(&to_msg);
  auto& from = static_cast<const GetBlockHeadersReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.GetBlockHeadersReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.block_headers_.MergeFrom(from._impl_.block_headers_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetBlockHeadersReply::CopyFrom(const GetBlockHeadersReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.GetBlockHeadersReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetBlockHeadersReply::IsInitialized() const {
  return true;
}

void GetBlockHeadersReply::InternalSwap(GetBlockHeadersReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.block_headers_.InternalSwap(&other->_impl_.block_headers_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetBlockHeadersReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[11]);
}

// ===================================================================

class GetBlocks::_Internal {
 public:
};

GetBlocks::GetBlocks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.GetBlocks)
}
GetBlocks::GetBlocks(const GetBlocks& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetBlocks* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.start_height_){}
    , decltype(_impl_.end_height_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.start_height_, &from._impl_.start_height_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.end_height_) -
    reinterpret_cast<char*>(&_impl_.start_height_)) + sizeof(_impl_.end_height_));
  // @@protoc_insertion_point(copy_constructor:pb.GetBlocks)
}

inline void GetBlocks::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.start_height_){0u}
    , decltype(_impl_.end_height_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GetBlocks::~GetBlocks() {
  // @@protoc_insertion_point(destructor:pb.GetBlocks)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetBlocks::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetBlocks::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetBlocks::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.GetBlocks)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.start_height_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.end_height_) -
      reinterpret_cast<char*>(&_impl_.start_height_)) + sizeof(_impl_.end_height_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetBlocks::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 start_height = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.start_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 end_height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.end_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetBlocks::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.GetBlocks)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 start_height = 1;
  if (this->_internal_start_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_start_height(), target);
  }

  // uint32 end_height = 2;
  if (this->_internal_end_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_end_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.GetBlocks)
  return target;
}

size_t GetBlocks::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.GetBlocks)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 start_height = 1;
  if (this->_internal_start_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_height());
  }

  // uint32 end_height = 2;
  if (this->_internal_end_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_height());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetBlocks::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetBlocks::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetBlocks::GetClassData() const { return &_class_data_; }


void GetBlocks::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetBlocks*>(&to_msg);
  auto& from = static_cast<const GetBlocks&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.GetBlocks)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_start_height() != 0) {
    _this->_internal_set_start_height(from._internal_start_height());
  }
  if (from._internal_end_height() != 0) {
    _this->_internal_set_end_height(from._internal_end_height());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetBlocks::CopyFrom(const GetBlocks& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.GetBlocks)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetBlocks::IsInitialized() const {
  return true;
}

void GetBlocks::InternalSwap(GetBlocks* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetBlocks, _impl_.end_height_)
      + sizeof(GetBlocks::_impl_.end_height_)
      - PROTOBUF_FIELD_OFFSET(GetBlocks, _impl_.start_height_)>(
          reinterpret_cast<char*>(&_impl_.start_height_),
          reinterpret_cast<char*>(&other->_impl_.start_height_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetBlocks::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[12]);
}

// ===================================================================

class GetBlocksReply::_Internal {
 public:
};

void GetBlocksReply::clear_blocks() {
  _impl_.blocks_.Clear();
}
GetBlocksReply::GetBlocksReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.GetBlocksReply)
}
GetBlocksReply::GetBlocksReply(const GetBlocksReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetBlocksReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.blocks_){from._impl_.blocks_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb.GetBlocksReply)
}

inline void GetBlocksReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.blocks_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GetBlocksReply::~GetBlocksReply() {
  // @@protoc_insertion_point(destructor:pb.GetBlocksReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetBlocksReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.blocks_.~RepeatedPtrField();
}

void GetBlocksReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetBlocksReply::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.GetBlocksReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.blocks_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetBlocksReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .pb.Block blocks = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_blocks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetBlocksReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.GetBlocksReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pb.Block blocks = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_blocks_size()); i < n; i++) {
    const auto& repfield = this->_internal_blocks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.GetBlocksReply)
  return target;
}

size_t GetBlocksReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.GetBlocksReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.Block blocks = 1;
  total_size += 1UL * this->_internal_blocks_size();
  for (const auto& msg : this->_impl_.blocks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetBlocksReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetBlocksReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetBlocksReply::GetClassData() const { return &_class_data_; }


void GetBlocksReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetBlocksReply*>(&to_msg);
  auto& from = static_cast<const GetBlocksReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.GetBlocksReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.blocks_.MergeFrom(from._impl_.blocks_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetBlocksReply::CopyFrom(const GetBlocksReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.GetBlocksReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetBlocksReply::IsInitialized() const {
  return true;
}

void GetBlocksReply::InternalSwap(GetBlocksReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.blocks_.InternalSwap(&other->_impl_.blocks_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetBlocksReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[13]);
}

// ===================================================================

class StateRequest::_Internal {
 public:
};

StateRequest::StateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.StateRequest)
}
StateRequest::StateRequest(const StateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StateRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hash_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hash().empty()) {
    _this->_impl_.hash_.Set(from._internal_hash(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:pb.StateRequest)
}

inline void StateRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hash_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StateRequest::~StateRequest() {
  // @@protoc_insertion_point(destructor:pb.StateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hash_.Destroy();
}

void StateRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.StateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hash_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.StateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes hash = 1;
  if (!this->_internal_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.StateRequest)
  return target;
}

size_t StateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.StateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes hash = 1;
  if (!this->_internal_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_hash());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StateRequest::GetClassData() const { return &_class_data_; }


void StateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StateRequest*>(&to_msg);
  auto& from = static_cast<const StateRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.StateRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_hash().empty()) {
    _this->_internal_set_hash(from._internal_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StateRequest::CopyFrom(const StateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.StateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StateRequest::IsInitialized() const {
  return true;
}

void StateRequest::InternalSwap(StateRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hash_, lhs_arena,
      &other->_impl_.hash_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StateRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[14]);
}

// ===================================================================

class StateNode::_Internal {
 public:
};

StateNode::StateNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.StateNode)
}
StateNode::StateNode(const StateNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StateNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.node_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.node_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.node_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_node().empty()) {
    _this->_impl_.node_.Set(from._internal_node(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:pb.StateNode)
}

inline void StateNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.node_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.node_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.node_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StateNode::~StateNode() {
  // @@protoc_insertion_point(destructor:pb.StateNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StateNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.node_.Destroy();
}

void StateNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StateNode::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.StateNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.node_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StateNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes node = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_node();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StateNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.StateNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes node = 1;
  if (!this->_internal_node().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_node(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.StateNode)
  return target;
}

size_t StateNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.StateNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes node = 1;
  if (!this->_internal_node().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_node());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StateNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StateNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StateNode::GetClassData() const { return &_class_data_; }


void StateNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StateNode*>(&to_msg);
  auto& from = static_cast<const StateNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.StateNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_node().empty()) {
    _this->_internal_set_node(from._internal_node());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StateNode::CopyFrom(const StateNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.StateNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StateNode::IsInitialized() const {
  return true;
}

void StateNode::InternalSwap(StateNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.node_, lhs_arena,
      &other->_impl_.node_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StateNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[15]);
}

// ===================================================================

class GetStates::_Internal {
 public:
};

GetStates::GetStates(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.GetStates)
}
GetStates::GetStates(const GetStates& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetStates* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.reqs_){from._impl_.reqs_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb.GetStates)
}

inline void GetStates::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.reqs_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GetStates::~GetStates() {
  // @@protoc_insertion_point(destructor:pb.GetStates)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetStates::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.reqs_.~RepeatedPtrField();
}

void GetStates::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetStates::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.GetStates)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.reqs_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetStates::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .pb.StateRequest reqs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_reqs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetStates::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.GetStates)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pb.StateRequest reqs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_reqs_size()); i < n; i++) {
    const auto& repfield = this->_internal_reqs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.GetStates)
  return target;
}

size_t GetStates::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.GetStates)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.StateRequest reqs = 1;
  total_size += 1UL * this->_internal_reqs_size();
  for (const auto& msg : this->_impl_.reqs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetStates::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetStates::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetStates::GetClassData() const { return &_class_data_; }


void GetStates::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetStates*>(&to_msg);
  auto& from = static_cast<const GetStates&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.GetStates)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.reqs_.MergeFrom(from._impl_.reqs_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetStates::CopyFrom(const GetStates& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.GetStates)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetStates::IsInitialized() const {
  return true;
}

void GetStates::InternalSwap(GetStates* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.reqs_.InternalSwap(&other->_impl_.reqs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetStates::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[16]);
}

// ===================================================================

class GetStatesReply::_Internal {
 public:
};

GetStatesReply::GetStatesReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.GetStatesReply)
}
GetStatesReply::GetStatesReply(const GetStatesReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetStatesReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){from._impl_.nodes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb.GetStatesReply)
}

inline void GetStatesReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GetStatesReply::~GetStatesReply() {
  // @@protoc_insertion_point(destructor:pb.GetStatesReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetStatesReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodes_.~RepeatedPtrField();
}

void GetStatesReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetStatesReply::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.GetStatesReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nodes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetStatesReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .pb.StateNode nodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetStatesReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.GetStatesReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pb.StateNode nodes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.GetStatesReply)
  return target;
}

size_t GetStatesReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.GetStatesReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.StateNode nodes = 1;
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->_impl_.nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetStatesReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetStatesReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetStatesReply::GetClassData() const { return &_class_data_; }


void GetStatesReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetStatesReply*>(&to_msg);
  auto& from = static_cast<const GetStatesReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.GetStatesReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nodes_.MergeFrom(from._impl_.nodes_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetStatesReply::CopyFrom(const GetStatesReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.GetStatesReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetStatesReply::IsInitialized() const {
  return true;
}

void GetStatesReply::InternalSwap(GetStatesReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nodes_.InternalSwap(&other->_impl_.nodes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetStatesReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[17]);
}

// ===================================================================

class Relay::_Internal {
 public:
};

Relay::Relay(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.Relay)
}
Relay::Relay(const Relay& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Relay* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.src_identifier_){}
    , decltype(_impl_.dest_id_){}
    , decltype(_impl_.payload_){}
    , decltype(_impl_.src_pubkey_){}
    , decltype(_impl_.block_hash_){}
    , decltype(_impl_.last_hash_){}
    , decltype(_impl_.max_holding_seconds_){}
    , decltype(_impl_.sig_chain_len_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.src_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.src_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_src_identifier().empty()) {
    _this->_impl_.src_identifier_.Set(from._internal_src_identifier(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dest_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dest_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_dest_id().empty()) {
    _this->_impl_.dest_id_.Set(from._internal_dest_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_payload().empty()) {
    _this->_impl_.payload_.Set(from._internal_payload(), 
      _this->GetArenaForAllocation());
  }
  _impl_.src_pubkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.src_pubkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_src_pubkey().empty()) {
    _this->_impl_.src_pubkey_.Set(from._internal_src_pubkey(), 
      _this->GetArenaForAllocation());
  }
  _impl_.block_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_block_hash().empty()) {
    _this->_impl_.block_hash_.Set(from._internal_block_hash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.last_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_last_hash().empty()) {
    _this->_impl_.last_hash_.Set(from._internal_last_hash(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.max_holding_seconds_, &from._impl_.max_holding_seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sig_chain_len_) -
    reinterpret_cast<char*>(&_impl_.max_holding_seconds_)) + sizeof(_impl_.sig_chain_len_));
  // @@protoc_insertion_point(copy_constructor:pb.Relay)
}

inline void Relay::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.src_identifier_){}
    , decltype(_impl_.dest_id_){}
    , decltype(_impl_.payload_){}
    , decltype(_impl_.src_pubkey_){}
    , decltype(_impl_.block_hash_){}
    , decltype(_impl_.last_hash_){}
    , decltype(_impl_.max_holding_seconds_){0u}
    , decltype(_impl_.sig_chain_len_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.src_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.src_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dest_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dest_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.src_pubkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.src_pubkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.block_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.block_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.last_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Relay::~Relay() {
  // @@protoc_insertion_point(destructor:pb.Relay)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Relay::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.src_identifier_.Destroy();
  _impl_.dest_id_.Destroy();
  _impl_.payload_.Destroy();
  _impl_.src_pubkey_.Destroy();
  _impl_.block_hash_.Destroy();
  _impl_.last_hash_.Destroy();
}

void Relay::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Relay::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.Relay)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.src_identifier_.ClearToEmpty();
  _impl_.dest_id_.ClearToEmpty();
  _impl_.payload_.ClearToEmpty();
  _impl_.src_pubkey_.ClearToEmpty();
  _impl_.block_hash_.ClearToEmpty();
  _impl_.last_hash_.ClearToEmpty();
  ::memset(&_impl_.max_holding_seconds_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.sig_chain_len_) -
      reinterpret_cast<char*>(&_impl_.max_holding_seconds_)) + sizeof(_impl_.sig_chain_len_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Relay::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string src_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_src_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pb.Relay.src_identifier"));
        } else
          goto handle_unusual;
        continue;
      // bytes dest_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_dest_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes payload = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 max_holding_seconds = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.max_holding_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes src_pubkey = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_src_pubkey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes block_hash = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_block_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes last_hash = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_last_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 sig_chain_len = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.sig_chain_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Relay::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.Relay)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string src_identifier = 1;
  if (!this->_internal_src_identifier().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_src_identifier().data(), static_cast<int>(this->_internal_src_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "pb.Relay.src_identifier");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_src_identifier(), target);
  }

  // bytes dest_id = 2;
  if (!this->_internal_dest_id().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_dest_id(), target);
  }

  // bytes payload = 3;
  if (!this->_internal_payload().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_payload(), target);
  }

  // uint32 max_holding_seconds = 5;
  if (this->_internal_max_holding_seconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_max_holding_seconds(), target);
  }

  // bytes src_pubkey = 6;
  if (!this->_internal_src_pubkey().empty()) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_src_pubkey(), target);
  }

  // bytes block_hash = 7;
  if (!this->_internal_block_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_block_hash(), target);
  }

  // bytes last_hash = 8;
  if (!this->_internal_last_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_last_hash(), target);
  }

  // uint32 sig_chain_len = 9;
  if (this->_internal_sig_chain_len() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_sig_chain_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.Relay)
  return target;
}

size_t Relay::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.Relay)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string src_identifier = 1;
  if (!this->_internal_src_identifier().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_src_identifier());
  }

  // bytes dest_id = 2;
  if (!this->_internal_dest_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_dest_id());
  }

  // bytes payload = 3;
  if (!this->_internal_payload().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_payload());
  }

  // bytes src_pubkey = 6;
  if (!this->_internal_src_pubkey().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_src_pubkey());
  }

  // bytes block_hash = 7;
  if (!this->_internal_block_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_block_hash());
  }

  // bytes last_hash = 8;
  if (!this->_internal_last_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_last_hash());
  }

  // uint32 max_holding_seconds = 5;
  if (this->_internal_max_holding_seconds() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_holding_seconds());
  }

  // uint32 sig_chain_len = 9;
  if (this->_internal_sig_chain_len() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sig_chain_len());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Relay::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Relay::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Relay::GetClassData() const { return &_class_data_; }


void Relay::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Relay*>(&to_msg);
  auto& from = static_cast<const Relay&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.Relay)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_src_identifier().empty()) {
    _this->_internal_set_src_identifier(from._internal_src_identifier());
  }
  if (!from._internal_dest_id().empty()) {
    _this->_internal_set_dest_id(from._internal_dest_id());
  }
  if (!from._internal_payload().empty()) {
    _this->_internal_set_payload(from._internal_payload());
  }
  if (!from._internal_src_pubkey().empty()) {
    _this->_internal_set_src_pubkey(from._internal_src_pubkey());
  }
  if (!from._internal_block_hash().empty()) {
    _this->_internal_set_block_hash(from._internal_block_hash());
  }
  if (!from._internal_last_hash().empty()) {
    _this->_internal_set_last_hash(from._internal_last_hash());
  }
  if (from._internal_max_holding_seconds() != 0) {
    _this->_internal_set_max_holding_seconds(from._internal_max_holding_seconds());
  }
  if (from._internal_sig_chain_len() != 0) {
    _this->_internal_set_sig_chain_len(from._internal_sig_chain_len());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Relay::CopyFrom(const Relay& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.Relay)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Relay::IsInitialized() const {
  return true;
}

void Relay::InternalSwap(Relay* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.src_identifier_, lhs_arena,
      &other->_impl_.src_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dest_id_, lhs_arena,
      &other->_impl_.dest_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.payload_, lhs_arena,
      &other->_impl_.payload_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.src_pubkey_, lhs_arena,
      &other->_impl_.src_pubkey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.block_hash_, lhs_arena,
      &other->_impl_.block_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.last_hash_, lhs_arena,
      &other->_impl_.last_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Relay, _impl_.sig_chain_len_)
      + sizeof(Relay::_impl_.sig_chain_len_)
      - PROTOBUF_FIELD_OFFSET(Relay, _impl_.max_holding_seconds_)>(
          reinterpret_cast<char*>(&_impl_.max_holding_seconds_),
          reinterpret_cast<char*>(&other->_impl_.max_holding_seconds_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Relay::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[18]);
}

// ===================================================================

class Transactions::_Internal {
 public:
};

void Transactions::clear_transactions() {
  _impl_.transactions_.Clear();
}
Transactions::Transactions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.Transactions)
}
Transactions::Transactions(const Transactions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Transactions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transactions_){from._impl_.transactions_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb.Transactions)
}

inline void Transactions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.transactions_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Transactions::~Transactions() {
  // @@protoc_insertion_point(destructor:pb.Transactions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Transactions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transactions_.~RepeatedPtrField();
}

void Transactions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Transactions::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.Transactions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transactions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Transactions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .pb.Transaction transactions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_transactions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Transactions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.Transactions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pb.Transaction transactions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_transactions_size()); i < n; i++) {
    const auto& repfield = this->_internal_transactions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.Transactions)
  return target;
}

size_t Transactions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.Transactions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.Transaction transactions = 1;
  total_size += 1UL * this->_internal_transactions_size();
  for (const auto& msg : this->_impl_.transactions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Transactions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Transactions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Transactions::GetClassData() const { return &_class_data_; }


void Transactions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Transactions*>(&to_msg);
  auto& from = static_cast<const Transactions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.Transactions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.transactions_.MergeFrom(from._impl_.transactions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Transactions::CopyFrom(const Transactions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.Transactions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transactions::IsInitialized() const {
  return true;
}

void Transactions::InternalSwap(Transactions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.transactions_.InternalSwap(&other->_impl_.transactions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Transactions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[19]);
}

// ===================================================================

class BacktrackSignatureChain::_Internal {
 public:
};

void BacktrackSignatureChain::clear_sig_chain_elems() {
  _impl_.sig_chain_elems_.Clear();
}
BacktrackSignatureChain::BacktrackSignatureChain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.BacktrackSignatureChain)
}
BacktrackSignatureChain::BacktrackSignatureChain(const BacktrackSignatureChain& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BacktrackSignatureChain* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sig_chain_elems_){from._impl_.sig_chain_elems_}
    , decltype(_impl_.hash_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hash().empty()) {
    _this->_impl_.hash_.Set(from._internal_hash(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:pb.BacktrackSignatureChain)
}

inline void BacktrackSignatureChain::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.sig_chain_elems_){arena}
    , decltype(_impl_.hash_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BacktrackSignatureChain::~BacktrackSignatureChain() {
  // @@protoc_insertion_point(destructor:pb.BacktrackSignatureChain)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BacktrackSignatureChain::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sig_chain_elems_.~RepeatedPtrField();
  _impl_.hash_.Destroy();
}

void BacktrackSignatureChain::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BacktrackSignatureChain::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.BacktrackSignatureChain)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sig_chain_elems_.Clear();
  _impl_.hash_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BacktrackSignatureChain::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .pb.SigChainElem sig_chain_elems = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sig_chain_elems(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bytes hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BacktrackSignatureChain::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.BacktrackSignatureChain)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pb.SigChainElem sig_chain_elems = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sig_chain_elems_size()); i < n; i++) {
    const auto& repfield = this->_internal_sig_chain_elems(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bytes hash = 2;
  if (!this->_internal_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.BacktrackSignatureChain)
  return target;
}

size_t BacktrackSignatureChain::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.BacktrackSignatureChain)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pb.SigChainElem sig_chain_elems = 1;
  total_size += 1UL * this->_internal_sig_chain_elems_size();
  for (const auto& msg : this->_impl_.sig_chain_elems_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bytes hash = 2;
  if (!this->_internal_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_hash());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BacktrackSignatureChain::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BacktrackSignatureChain::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BacktrackSignatureChain::GetClassData() const { return &_class_data_; }


void BacktrackSignatureChain::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BacktrackSignatureChain*>(&to_msg);
  auto& from = static_cast<const BacktrackSignatureChain&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.BacktrackSignatureChain)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.sig_chain_elems_.MergeFrom(from._impl_.sig_chain_elems_);
  if (!from._internal_hash().empty()) {
    _this->_internal_set_hash(from._internal_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BacktrackSignatureChain::CopyFrom(const BacktrackSignatureChain& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.BacktrackSignatureChain)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BacktrackSignatureChain::IsInitialized() const {
  return true;
}

void BacktrackSignatureChain::InternalSwap(BacktrackSignatureChain* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.sig_chain_elems_.InternalSwap(&other->_impl_.sig_chain_elems_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hash_, lhs_arena,
      &other->_impl_.hash_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata BacktrackSignatureChain::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[20]);
}

// ===================================================================

class IHaveSignatureChainTransaction::_Internal {
 public:
};

IHaveSignatureChainTransaction::IHaveSignatureChainTransaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.IHaveSignatureChainTransaction)
}
IHaveSignatureChainTransaction::IHaveSignatureChainTransaction(const IHaveSignatureChainTransaction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IHaveSignatureChainTransaction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.signature_hash_){}
    , decltype(_impl_.height_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.signature_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_signature_hash().empty()) {
    _this->_impl_.signature_hash_.Set(from._internal_signature_hash(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.height_ = from._impl_.height_;
  // @@protoc_insertion_point(copy_constructor:pb.IHaveSignatureChainTransaction)
}

inline void IHaveSignatureChainTransaction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.signature_hash_){}
    , decltype(_impl_.height_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.signature_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IHaveSignatureChainTransaction::~IHaveSignatureChainTransaction() {
  // @@protoc_insertion_point(destructor:pb.IHaveSignatureChainTransaction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IHaveSignatureChainTransaction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.signature_hash_.Destroy();
}

void IHaveSignatureChainTransaction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IHaveSignatureChainTransaction::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.IHaveSignatureChainTransaction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.signature_hash_.ClearToEmpty();
  _impl_.height_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IHaveSignatureChainTransaction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 height = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes signature_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_signature_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IHaveSignatureChainTransaction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.IHaveSignatureChainTransaction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 height = 1;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_height(), target);
  }

  // bytes signature_hash = 2;
  if (!this->_internal_signature_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_signature_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.IHaveSignatureChainTransaction)
  return target;
}

size_t IHaveSignatureChainTransaction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.IHaveSignatureChainTransaction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes signature_hash = 2;
  if (!this->_internal_signature_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature_hash());
  }

  // uint32 height = 1;
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IHaveSignatureChainTransaction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IHaveSignatureChainTransaction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IHaveSignatureChainTransaction::GetClassData() const { return &_class_data_; }


void IHaveSignatureChainTransaction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IHaveSignatureChainTransaction*>(&to_msg);
  auto& from = static_cast<const IHaveSignatureChainTransaction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.IHaveSignatureChainTransaction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_signature_hash().empty()) {
    _this->_internal_set_signature_hash(from._internal_signature_hash());
  }
  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IHaveSignatureChainTransaction::CopyFrom(const IHaveSignatureChainTransaction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.IHaveSignatureChainTransaction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IHaveSignatureChainTransaction::IsInitialized() const {
  return true;
}

void IHaveSignatureChainTransaction::InternalSwap(IHaveSignatureChainTransaction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_hash_, lhs_arena,
      &other->_impl_.signature_hash_, rhs_arena
  );
  swap(_impl_.height_, other->_impl_.height_);
}

::PROTOBUF_NAMESPACE_ID::Metadata IHaveSignatureChainTransaction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[21]);
}

// ===================================================================

class RequestSignatureChainTransaction::_Internal {
 public:
};

RequestSignatureChainTransaction::RequestSignatureChainTransaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.RequestSignatureChainTransaction)
}
RequestSignatureChainTransaction::RequestSignatureChainTransaction(const RequestSignatureChainTransaction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestSignatureChainTransaction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.signature_hash_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.signature_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_signature_hash().empty()) {
    _this->_impl_.signature_hash_.Set(from._internal_signature_hash(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:pb.RequestSignatureChainTransaction)
}

inline void RequestSignatureChainTransaction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.signature_hash_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.signature_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RequestSignatureChainTransaction::~RequestSignatureChainTransaction() {
  // @@protoc_insertion_point(destructor:pb.RequestSignatureChainTransaction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestSignatureChainTransaction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.signature_hash_.Destroy();
}

void RequestSignatureChainTransaction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestSignatureChainTransaction::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.RequestSignatureChainTransaction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.signature_hash_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestSignatureChainTransaction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes signature_hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_signature_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestSignatureChainTransaction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.RequestSignatureChainTransaction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes signature_hash = 1;
  if (!this->_internal_signature_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_signature_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.RequestSignatureChainTransaction)
  return target;
}

size_t RequestSignatureChainTransaction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.RequestSignatureChainTransaction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes signature_hash = 1;
  if (!this->_internal_signature_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature_hash());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestSignatureChainTransaction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestSignatureChainTransaction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestSignatureChainTransaction::GetClassData() const { return &_class_data_; }


void RequestSignatureChainTransaction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestSignatureChainTransaction*>(&to_msg);
  auto& from = static_cast<const RequestSignatureChainTransaction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.RequestSignatureChainTransaction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_signature_hash().empty()) {
    _this->_internal_set_signature_hash(from._internal_signature_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestSignatureChainTransaction::CopyFrom(const RequestSignatureChainTransaction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.RequestSignatureChainTransaction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSignatureChainTransaction::IsInitialized() const {
  return true;
}

void RequestSignatureChainTransaction::InternalSwap(RequestSignatureChainTransaction* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_hash_, lhs_arena,
      &other->_impl_.signature_hash_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestSignatureChainTransaction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[22]);
}

// ===================================================================

class RequestSignatureChainTransactionReply::_Internal {
 public:
  static const ::pb::Transaction& transaction(const RequestSignatureChainTransactionReply* msg);
};

const ::pb::Transaction&
RequestSignatureChainTransactionReply::_Internal::transaction(const RequestSignatureChainTransactionReply* msg) {
  return *msg->_impl_.transaction_;
}
void RequestSignatureChainTransactionReply::clear_transaction() {
  if (GetArenaForAllocation() == nullptr && _impl_.transaction_ != nullptr) {
    delete _impl_.transaction_;
  }
  _impl_.transaction_ = nullptr;
}
RequestSignatureChainTransactionReply::RequestSignatureChainTransactionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.RequestSignatureChainTransactionReply)
}
RequestSignatureChainTransactionReply::RequestSignatureChainTransactionReply(const RequestSignatureChainTransactionReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestSignatureChainTransactionReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transaction_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_transaction()) {
    _this->_impl_.transaction_ = new ::pb::Transaction(*from._impl_.transaction_);
  }
  // @@protoc_insertion_point(copy_constructor:pb.RequestSignatureChainTransactionReply)
}

inline void RequestSignatureChainTransactionReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.transaction_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RequestSignatureChainTransactionReply::~RequestSignatureChainTransactionReply() {
  // @@protoc_insertion_point(destructor:pb.RequestSignatureChainTransactionReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequestSignatureChainTransactionReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.transaction_;
}

void RequestSignatureChainTransactionReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestSignatureChainTransactionReply::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.RequestSignatureChainTransactionReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.transaction_ != nullptr) {
    delete _impl_.transaction_;
  }
  _impl_.transaction_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestSignatureChainTransactionReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .pb.Transaction transaction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestSignatureChainTransactionReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.RequestSignatureChainTransactionReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .pb.Transaction transaction = 1;
  if (this->_internal_has_transaction()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::transaction(this),
        _Internal::transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.RequestSignatureChainTransactionReply)
  return target;
}

size_t RequestSignatureChainTransactionReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.RequestSignatureChainTransactionReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .pb.Transaction transaction = 1;
  if (this->_internal_has_transaction()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.transaction_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestSignatureChainTransactionReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestSignatureChainTransactionReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestSignatureChainTransactionReply::GetClassData() const { return &_class_data_; }


void RequestSignatureChainTransactionReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestSignatureChainTransactionReply*>(&to_msg);
  auto& from = static_cast<const RequestSignatureChainTransactionReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.RequestSignatureChainTransactionReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_transaction()) {
    _this->_internal_mutable_transaction()->::pb::Transaction::MergeFrom(
        from._internal_transaction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestSignatureChainTransactionReply::CopyFrom(const RequestSignatureChainTransactionReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.RequestSignatureChainTransactionReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSignatureChainTransactionReply::IsInitialized() const {
  return true;
}

void RequestSignatureChainTransactionReply::InternalSwap(RequestSignatureChainTransactionReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.transaction_, other->_impl_.transaction_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestSignatureChainTransactionReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[23]);
}

// ===================================================================

class PinSignatureChain::_Internal {
 public:
};

PinSignatureChain::PinSignatureChain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.PinSignatureChain)
}
PinSignatureChain::PinSignatureChain(const PinSignatureChain& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PinSignatureChain* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hash_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hash().empty()) {
    _this->_impl_.hash_.Set(from._internal_hash(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:pb.PinSignatureChain)
}

inline void PinSignatureChain::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hash_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PinSignatureChain::~PinSignatureChain() {
  // @@protoc_insertion_point(destructor:pb.PinSignatureChain)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PinSignatureChain::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hash_.Destroy();
}

void PinSignatureChain::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PinSignatureChain::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.PinSignatureChain)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hash_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PinSignatureChain::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PinSignatureChain::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.PinSignatureChain)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes hash = 1;
  if (!this->_internal_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.PinSignatureChain)
  return target;
}

size_t PinSignatureChain::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.PinSignatureChain)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes hash = 1;
  if (!this->_internal_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_hash());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PinSignatureChain::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PinSignatureChain::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PinSignatureChain::GetClassData() const { return &_class_data_; }


void PinSignatureChain::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PinSignatureChain*>(&to_msg);
  auto& from = static_cast<const PinSignatureChain&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.PinSignatureChain)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_hash().empty()) {
    _this->_internal_set_hash(from._internal_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PinSignatureChain::CopyFrom(const PinSignatureChain& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.PinSignatureChain)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PinSignatureChain::IsInitialized() const {
  return true;
}

void PinSignatureChain::InternalSwap(PinSignatureChain* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hash_, lhs_arena,
      &other->_impl_.hash_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PinSignatureChain::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[24]);
}

// ===================================================================

class SignatureChainObjectionUnsigned::_Internal {
 public:
};

SignatureChainObjectionUnsigned::SignatureChainObjectionUnsigned(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.SignatureChainObjectionUnsigned)
}
SignatureChainObjectionUnsigned::SignatureChainObjectionUnsigned(const SignatureChainObjectionUnsigned& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SignatureChainObjectionUnsigned* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.signature_hash_){}
    , decltype(_impl_.reporter_pubkey_){}
    , decltype(_impl_.height_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.signature_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_signature_hash().empty()) {
    _this->_impl_.signature_hash_.Set(from._internal_signature_hash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.reporter_pubkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reporter_pubkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_reporter_pubkey().empty()) {
    _this->_impl_.reporter_pubkey_.Set(from._internal_reporter_pubkey(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.height_ = from._impl_.height_;
  // @@protoc_insertion_point(copy_constructor:pb.SignatureChainObjectionUnsigned)
}

inline void SignatureChainObjectionUnsigned::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.signature_hash_){}
    , decltype(_impl_.reporter_pubkey_){}
    , decltype(_impl_.height_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.signature_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.reporter_pubkey_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reporter_pubkey_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SignatureChainObjectionUnsigned::~SignatureChainObjectionUnsigned() {
  // @@protoc_insertion_point(destructor:pb.SignatureChainObjectionUnsigned)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SignatureChainObjectionUnsigned::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.signature_hash_.Destroy();
  _impl_.reporter_pubkey_.Destroy();
}

void SignatureChainObjectionUnsigned::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SignatureChainObjectionUnsigned::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.SignatureChainObjectionUnsigned)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.signature_hash_.ClearToEmpty();
  _impl_.reporter_pubkey_.ClearToEmpty();
  _impl_.height_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignatureChainObjectionUnsigned::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 height = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes signature_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_signature_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes reporter_pubkey = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_reporter_pubkey();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SignatureChainObjectionUnsigned::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.SignatureChainObjectionUnsigned)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 height = 1;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_height(), target);
  }

  // bytes signature_hash = 2;
  if (!this->_internal_signature_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_signature_hash(), target);
  }

  // bytes reporter_pubkey = 3;
  if (!this->_internal_reporter_pubkey().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_reporter_pubkey(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.SignatureChainObjectionUnsigned)
  return target;
}

size_t SignatureChainObjectionUnsigned::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.SignatureChainObjectionUnsigned)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes signature_hash = 2;
  if (!this->_internal_signature_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature_hash());
  }

  // bytes reporter_pubkey = 3;
  if (!this->_internal_reporter_pubkey().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_reporter_pubkey());
  }

  // uint32 height = 1;
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignatureChainObjectionUnsigned::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SignatureChainObjectionUnsigned::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignatureChainObjectionUnsigned::GetClassData() const { return &_class_data_; }


void SignatureChainObjectionUnsigned::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SignatureChainObjectionUnsigned*>(&to_msg);
  auto& from = static_cast<const SignatureChainObjectionUnsigned&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.SignatureChainObjectionUnsigned)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_signature_hash().empty()) {
    _this->_internal_set_signature_hash(from._internal_signature_hash());
  }
  if (!from._internal_reporter_pubkey().empty()) {
    _this->_internal_set_reporter_pubkey(from._internal_reporter_pubkey());
  }
  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignatureChainObjectionUnsigned::CopyFrom(const SignatureChainObjectionUnsigned& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.SignatureChainObjectionUnsigned)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignatureChainObjectionUnsigned::IsInitialized() const {
  return true;
}

void SignatureChainObjectionUnsigned::InternalSwap(SignatureChainObjectionUnsigned* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_hash_, lhs_arena,
      &other->_impl_.signature_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reporter_pubkey_, lhs_arena,
      &other->_impl_.reporter_pubkey_, rhs_arena
  );
  swap(_impl_.height_, other->_impl_.height_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SignatureChainObjectionUnsigned::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[25]);
}

// ===================================================================

class SignatureChainObjectionSigned::_Internal {
 public:
};

SignatureChainObjectionSigned::SignatureChainObjectionSigned(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pb.SignatureChainObjectionSigned)
}
SignatureChainObjectionSigned::SignatureChainObjectionSigned(const SignatureChainObjectionSigned& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SignatureChainObjectionSigned* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.signature_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_signature().empty()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:pb.SignatureChainObjectionSigned)
}

inline void SignatureChainObjectionSigned::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.signature_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SignatureChainObjectionSigned::~SignatureChainObjectionSigned() {
  // @@protoc_insertion_point(destructor:pb.SignatureChainObjectionSigned)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SignatureChainObjectionSigned::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
  _impl_.signature_.Destroy();
}

void SignatureChainObjectionSigned::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SignatureChainObjectionSigned::Clear() {
// @@protoc_insertion_point(message_clear_start:pb.SignatureChainObjectionSigned)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _impl_.signature_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignatureChainObjectionSigned::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes signature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SignatureChainObjectionSigned::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.SignatureChainObjectionSigned)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes message = 1;
  if (!this->_internal_message().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_message(), target);
  }

  // bytes signature = 2;
  if (!this->_internal_signature().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.SignatureChainObjectionSigned)
  return target;
}

size_t SignatureChainObjectionSigned::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb.SignatureChainObjectionSigned)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes message = 1;
  if (!this->_internal_message().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_message());
  }

  // bytes signature = 2;
  if (!this->_internal_signature().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignatureChainObjectionSigned::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SignatureChainObjectionSigned::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignatureChainObjectionSigned::GetClassData() const { return &_class_data_; }


void SignatureChainObjectionSigned::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SignatureChainObjectionSigned*>(&to_msg);
  auto& from = static_cast<const SignatureChainObjectionSigned&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb.SignatureChainObjectionSigned)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  if (!from._internal_signature().empty()) {
    _this->_internal_set_signature(from._internal_signature());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignatureChainObjectionSigned::CopyFrom(const SignatureChainObjectionSigned& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb.SignatureChainObjectionSigned)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignatureChainObjectionSigned::IsInitialized() const {
  return true;
}

void SignatureChainObjectionSigned::InternalSwap(SignatureChainObjectionSigned* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SignatureChainObjectionSigned::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pb_2fnodemessage_2eproto_getter, &descriptor_table_pb_2fnodemessage_2eproto_once,
      file_level_metadata_pb_2fnodemessage_2eproto[26]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace pb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::pb::UnsignedMessage*
Arena::CreateMaybeMessage< ::pb::UnsignedMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::UnsignedMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::SignedMessage*
Arena::CreateMaybeMessage< ::pb::SignedMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::SignedMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::Vote*
Arena::CreateMaybeMessage< ::pb::Vote >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::Vote >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::IHaveBlockProposal*
Arena::CreateMaybeMessage< ::pb::IHaveBlockProposal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::IHaveBlockProposal >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::RequestBlockProposal*
Arena::CreateMaybeMessage< ::pb::RequestBlockProposal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::RequestBlockProposal >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::RequestBlockProposalReply*
Arena::CreateMaybeMessage< ::pb::RequestBlockProposalReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::RequestBlockProposalReply >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::RequestProposalTransactions*
Arena::CreateMaybeMessage< ::pb::RequestProposalTransactions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::RequestProposalTransactions >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::RequestProposalTransactionsReply*
Arena::CreateMaybeMessage< ::pb::RequestProposalTransactionsReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::RequestProposalTransactionsReply >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::GetConsensusState*
Arena::CreateMaybeMessage< ::pb::GetConsensusState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::GetConsensusState >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::GetConsensusStateReply*
Arena::CreateMaybeMessage< ::pb::GetConsensusStateReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::GetConsensusStateReply >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::GetBlockHeaders*
Arena::CreateMaybeMessage< ::pb::GetBlockHeaders >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::GetBlockHeaders >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::GetBlockHeadersReply*
Arena::CreateMaybeMessage< ::pb::GetBlockHeadersReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::GetBlockHeadersReply >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::GetBlocks*
Arena::CreateMaybeMessage< ::pb::GetBlocks >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::GetBlocks >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::GetBlocksReply*
Arena::CreateMaybeMessage< ::pb::GetBlocksReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::GetBlocksReply >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::StateRequest*
Arena::CreateMaybeMessage< ::pb::StateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::StateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::StateNode*
Arena::CreateMaybeMessage< ::pb::StateNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::StateNode >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::GetStates*
Arena::CreateMaybeMessage< ::pb::GetStates >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::GetStates >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::GetStatesReply*
Arena::CreateMaybeMessage< ::pb::GetStatesReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::GetStatesReply >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::Relay*
Arena::CreateMaybeMessage< ::pb::Relay >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::Relay >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::Transactions*
Arena::CreateMaybeMessage< ::pb::Transactions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::Transactions >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::BacktrackSignatureChain*
Arena::CreateMaybeMessage< ::pb::BacktrackSignatureChain >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::BacktrackSignatureChain >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::IHaveSignatureChainTransaction*
Arena::CreateMaybeMessage< ::pb::IHaveSignatureChainTransaction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::IHaveSignatureChainTransaction >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::RequestSignatureChainTransaction*
Arena::CreateMaybeMessage< ::pb::RequestSignatureChainTransaction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::RequestSignatureChainTransaction >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::RequestSignatureChainTransactionReply*
Arena::CreateMaybeMessage< ::pb::RequestSignatureChainTransactionReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::RequestSignatureChainTransactionReply >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::PinSignatureChain*
Arena::CreateMaybeMessage< ::pb::PinSignatureChain >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::PinSignatureChain >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::SignatureChainObjectionUnsigned*
Arena::CreateMaybeMessage< ::pb::SignatureChainObjectionUnsigned >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::SignatureChainObjectionUnsigned >(arena);
}
template<> PROTOBUF_NOINLINE ::pb::SignatureChainObjectionSigned*
Arena::CreateMaybeMessage< ::pb::SignatureChainObjectionSigned >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pb::SignatureChainObjectionSigned >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
